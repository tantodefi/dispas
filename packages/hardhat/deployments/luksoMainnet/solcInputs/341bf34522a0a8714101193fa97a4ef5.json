{
  "language": "Solidity",
  "sources": {
    "@erc725/smart-contracts/contracts/constants.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n// ERC165 INTERFACE IDs\nbytes4 constant _INTERFACEID_ERC725X = 0x570ef073;\nbytes4 constant _INTERFACEID_ERC725Y = 0x714df77c;\n\n// ERC725X overloaded function selectors\nbytes4 constant EXECUTE_SELECTOR = 0x44c028fe;\nbytes4 constant EXECUTE_ARRAY_SELECTOR = 0x13ced88d;\n\n// ERC725X OPERATION TYPES\nuint256 constant OPERATION_0_CALL = 0;\nuint256 constant OPERATION_1_CREATE = 1;\nuint256 constant OPERATION_2_CREATE2 = 2;\nuint256 constant OPERATION_3_STATICCALL = 3;\nuint256 constant OPERATION_4_DELEGATECALL = 4;\n\n// ERC725Y overloaded function selectors\nbytes4 constant SETDATA_SELECTOR = 0x7f23690c;\nbytes4 constant SETDATA_ARRAY_SELECTOR = 0x14a6e293;\n"
    },
    "@erc725/smart-contracts/contracts/custom/OwnableUnset.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title OwnableUnset\n * @dev modified version of OpenZeppelin implementation, where:\n * - _setOwner(address) function is internal, so this function can be used in constructor\n * of contracts implementation (instead of using transferOwnership(address)\n * - the contract does not inherit from Context contract\n */\nabstract contract OwnableUnset {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == msg.sender, \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Changes the owner if `newOwner` and oldOwner are different\n     * This pattern is useful in inheritance.\n     */\n    function _setOwner(address newOwner) internal virtual {\n        if (newOwner != owner()) {\n            address oldOwner = _owner;\n            _owner = newOwner;\n            emit OwnershipTransferred(oldOwner, newOwner);\n        }\n    }\n}\n"
    },
    "@erc725/smart-contracts/contracts/ERC725XCore.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n// interfaces\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {IERC725X} from \"./interfaces/IERC725X.sol\";\n\n// libraries\nimport {Create2} from \"@openzeppelin/contracts/utils/Create2.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\n// modules\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {OwnableUnset} from \"./custom/OwnableUnset.sol\";\n\n// constants\nimport {\n    _INTERFACEID_ERC725X,\n    OPERATION_0_CALL,\n    OPERATION_1_CREATE,\n    OPERATION_2_CREATE2,\n    OPERATION_3_STATICCALL,\n    OPERATION_4_DELEGATECALL\n} from \"./constants.sol\";\n\nimport \"./errors.sol\";\n\n/**\n * @title Core implementation of ERC725X executor\n * @author Fabian Vogelsteller <fabian@lukso.network>\n * @dev Implementation of a contract module which provides the ability to call arbitrary functions at any other smart contract and itself,\n * including using `delegatecall`, `staticcall` as well creating contracts using `create` and `create2`\n * This is the basis for a smart contract based account system, but could also be used as a proxy account system\n */\nabstract contract ERC725XCore is OwnableUnset, ERC165, IERC725X {\n    /**\n     * @inheritdoc IERC725X\n     */\n    function execute(\n        uint256 operationType,\n        address target,\n        uint256 value,\n        bytes memory data\n    ) public payable virtual override onlyOwner returns (bytes memory) {\n        return _execute(operationType, target, value, data);\n    }\n\n    /**\n     * @inheritdoc IERC725X\n     */\n    function execute(\n        uint256[] memory operationsType,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory datas\n    ) public payable virtual override onlyOwner returns (bytes[] memory) {\n        return _execute(operationsType, targets, values, datas);\n    }\n\n    /**\n     * @inheritdoc ERC165\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(IERC165, ERC165) returns (bool) {\n        return interfaceId == _INTERFACEID_ERC725X || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev check the `operationType` provided and perform the associated low-level opcode.\n     * see `IERC725X.execute(uint256,address,uint256,bytes)`.\n     */\n    function _execute(\n        uint256 operationType,\n        address target,\n        uint256 value,\n        bytes memory data\n    ) internal virtual returns (bytes memory) {\n        // CALL\n        if (operationType == OPERATION_0_CALL) {\n            return _executeCall(target, value, data);\n        }\n\n        // Deploy with CREATE\n        if (operationType == uint256(OPERATION_1_CREATE)) {\n            if (target != address(0)) revert ERC725X_CreateOperationsRequireEmptyRecipientAddress();\n            return _deployCreate(value, data);\n        }\n\n        // Deploy with CREATE2\n        if (operationType == uint256(OPERATION_2_CREATE2)) {\n            if (target != address(0)) revert ERC725X_CreateOperationsRequireEmptyRecipientAddress();\n            return _deployCreate2(value, data);\n        }\n\n        // STATICCALL\n        if (operationType == uint256(OPERATION_3_STATICCALL)) {\n            if (value != 0) revert ERC725X_MsgValueDisallowedInStaticCall();\n            return _executeStaticCall(target, data);\n        }\n\n        // DELEGATECALL\n        //\n        // WARNING! delegatecall is a dangerous operation type! use with EXTRA CAUTION\n        //\n        // delegate allows to call another deployed contract and use its functions\n        // to update the state of the current calling contract.\n        //\n        // this can lead to unexpected behaviour on the contract storage, such as:\n        // - updating any state variables (even if these are protected)\n        // - update the contract owner\n        // - run selfdestruct in the context of this contract\n        //\n        if (operationType == uint256(OPERATION_4_DELEGATECALL)) {\n            if (value != 0) revert ERC725X_MsgValueDisallowedInDelegateCall();\n            return _executeDelegateCall(target, data);\n        }\n\n        revert ERC725X_UnknownOperationType(operationType);\n    }\n\n    /**\n     * @dev same as `_execute` but for batch execution\n     * see `IERC725X,execute(uint256[],address[],uint256[],bytes[])`\n     */\n    function _execute(\n        uint256[] memory operationsType,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory datas\n    ) internal virtual returns (bytes[] memory) {\n        if (\n            operationsType.length != targets.length ||\n            (targets.length != values.length || values.length != datas.length)\n        ) revert ERC725X_ExecuteParametersLengthMismatch();\n\n        bytes[] memory result = new bytes[](operationsType.length);\n\n        for (uint256 i = 0; i < operationsType.length; i = _uncheckedIncrementERC725X(i)) {\n            result[i] = _execute(operationsType[i], targets[i], values[i], datas[i]);\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev perform low-level call (operation type = 0)\n     * @param target The address on which call is executed\n     * @param value The value to be sent with the call\n     * @param data The data to be sent with the call\n     * @return result The data from the call\n     */\n    function _executeCall(\n        address target,\n        uint256 value,\n        bytes memory data\n    ) internal virtual returns (bytes memory result) {\n        if (address(this).balance < value) {\n            revert ERC725X_InsufficientBalance(address(this).balance, value);\n        }\n\n        emit Executed(OPERATION_0_CALL, target, value, bytes4(data));\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returnData) = target.call{value: value}(data);\n        result = Address.verifyCallResult(success, returnData, \"ERC725X: Unknown Error\");\n    }\n\n    /**\n     * @dev perform low-level staticcall (operation type = 3)\n     * @param target The address on which staticcall is executed\n     * @param data The data to be sent with the staticcall\n     * @return result The data returned from the staticcall\n     */\n    function _executeStaticCall(\n        address target,\n        bytes memory data\n    ) internal virtual returns (bytes memory result) {\n        emit Executed(OPERATION_3_STATICCALL, target, 0, bytes4(data));\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returnData) = target.staticcall(data);\n        result = Address.verifyCallResult(success, returnData, \"ERC725X: Unknown Error\");\n    }\n\n    /**\n     * @dev perform low-level delegatecall (operation type = 4)\n     * @param target The address on which delegatecall is executed\n     * @param data The data to be sent with the delegatecall\n     * @return result The data returned from the delegatecall\n     */\n    function _executeDelegateCall(\n        address target,\n        bytes memory data\n    ) internal virtual returns (bytes memory result) {\n        emit Executed(OPERATION_4_DELEGATECALL, target, 0, bytes4(data));\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returnData) = target.delegatecall(data);\n        result = Address.verifyCallResult(success, returnData, \"ERC725X: Unknown Error\");\n    }\n\n    /**\n     * @dev deploy a contract using the CREATE opcode (operation type = 1)\n     * @param value The value to be sent to the contract created\n     * @param creationCode The contract creation bytecode to deploy appended with the constructor argument(s)\n     * @return newContract The address of the contract created as bytes\n     */\n    function _deployCreate(\n        uint256 value,\n        bytes memory creationCode\n    ) internal virtual returns (bytes memory newContract) {\n        if (address(this).balance < value) {\n            revert ERC725X_InsufficientBalance(address(this).balance, value);\n        }\n\n        if (creationCode.length == 0) {\n            revert ERC725X_NoContractBytecodeProvided();\n        }\n\n        address contractAddress;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            contractAddress := create(value, add(creationCode, 0x20), mload(creationCode))\n        }\n\n        if (contractAddress == address(0)) {\n            revert ERC725X_ContractDeploymentFailed();\n        }\n\n        newContract = abi.encodePacked(contractAddress);\n        emit ContractCreated(OPERATION_1_CREATE, contractAddress, value, bytes32(0));\n    }\n\n    /**\n     * @dev deploy a contract using the CREATE2 opcode (operation type = 2)\n     * @param value The value to be sent to the contract created\n     * @param creationCode The contract creation bytecode to deploy appended with the constructor argument(s) and a bytes32 salt\n     * @return newContract The address of the contract created as bytes\n     */\n    function _deployCreate2(\n        uint256 value,\n        bytes memory creationCode\n    ) internal virtual returns (bytes memory newContract) {\n        if (creationCode.length == 0) {\n            revert ERC725X_NoContractBytecodeProvided();\n        }\n\n        bytes32 salt = BytesLib.toBytes32(creationCode, creationCode.length - 32);\n        bytes memory bytecode = BytesLib.slice(creationCode, 0, creationCode.length - 32);\n        address contractAddress = Create2.deploy(value, salt, bytecode);\n\n        newContract = abi.encodePacked(contractAddress);\n        emit ContractCreated(OPERATION_2_CREATE2, contractAddress, value, salt);\n    }\n\n    /**\n     * @dev Will return unchecked incremented uint256\n     *      can be used to save gas when iterating over loops\n     */\n    function _uncheckedIncrementERC725X(uint256 i) internal pure returns (uint256) {\n        unchecked {\n            return i + 1;\n        }\n    }\n}\n"
    },
    "@erc725/smart-contracts/contracts/ERC725Y.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n// modules\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {OwnableUnset} from \"./custom/OwnableUnset.sol\";\nimport {ERC725YCore} from \"./ERC725YCore.sol\";\n\n/**\n * @title ERC725Y General data key/value store\n * @author Fabian Vogelsteller <fabian@lukso.network>\n * @dev Contract module which provides the ability to set arbitrary data key/value pairs that can be changed over time\n * It is intended to standardise certain data key/value pairs to allow automated read and writes\n * from/to the contract storage\n */\ncontract ERC725Y is ERC725YCore {\n    /**\n     * @notice Sets the owner of the contract\n     * @param newOwner the owner of the contract\n     */\n    constructor(address newOwner) {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        OwnableUnset._setOwner(newOwner);\n    }\n}\n"
    },
    "@erc725/smart-contracts/contracts/ERC725YCore.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n// interfaces\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {IERC725Y} from \"./interfaces/IERC725Y.sol\";\n\n// modules\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {OwnableUnset} from \"./custom/OwnableUnset.sol\";\n\n// constants\nimport {_INTERFACEID_ERC725Y} from \"./constants.sol\";\n\nimport \"./errors.sol\";\n\n/**\n * @title Core implementation of ERC725Y General data key/value store\n * @author Fabian Vogelsteller <fabian@lukso.network>\n * @dev Contract module which provides the ability to set arbitrary data key/value pairs that can be changed over time\n * It is intended to standardise certain data key/value pairs to allow automated read and writes\n * from/to the contract storage\n */\nabstract contract ERC725YCore is OwnableUnset, ERC165, IERC725Y {\n    /**\n     * @dev Map the dataKeys to their dataValues\n     */\n    mapping(bytes32 => bytes) internal _store;\n\n    /**\n     * @inheritdoc IERC725Y\n     */\n    function getData(\n        bytes32 dataKey\n    ) public view virtual override returns (bytes memory dataValue) {\n        dataValue = _getData(dataKey);\n    }\n\n    /**\n     * @inheritdoc IERC725Y\n     */\n    function getData(\n        bytes32[] memory dataKeys\n    ) public view virtual override returns (bytes[] memory dataValues) {\n        dataValues = new bytes[](dataKeys.length);\n\n        for (uint256 i = 0; i < dataKeys.length; i = _uncheckedIncrementERC725Y(i)) {\n            dataValues[i] = _getData(dataKeys[i]);\n        }\n\n        return dataValues;\n    }\n\n    /**\n     * @inheritdoc IERC725Y\n     */\n    function setData(\n        bytes32 dataKey,\n        bytes memory dataValue\n    ) public payable virtual override onlyOwner {\n        if (msg.value != 0) revert ERC725Y_MsgValueDisallowed();\n        _setData(dataKey, dataValue);\n    }\n\n    /**\n     * @inheritdoc IERC725Y\n     */\n    function setData(\n        bytes32[] memory dataKeys,\n        bytes[] memory dataValues\n    ) public payable virtual override onlyOwner {\n        /// @dev do not allow to send value by default when setting data in ERC725Y\n        if (msg.value != 0) revert ERC725Y_MsgValueDisallowed();\n\n        if (dataKeys.length != dataValues.length) {\n            revert ERC725Y_DataKeysValuesLengthMismatch(dataKeys.length, dataValues.length);\n        }\n\n        for (uint256 i = 0; i < dataKeys.length; i = _uncheckedIncrementERC725Y(i)) {\n            _setData(dataKeys[i], dataValues[i]);\n        }\n    }\n\n    function _getData(bytes32 dataKey) internal view virtual returns (bytes memory dataValue) {\n        return _store[dataKey];\n    }\n\n    function _setData(bytes32 dataKey, bytes memory dataValue) internal virtual {\n        _store[dataKey] = dataValue;\n        emit DataChanged(dataKey, dataValue);\n    }\n\n    /**\n     * @dev Will return unchecked incremented uint256\n     *      can be used to save gas when iterating over loops\n     */\n    function _uncheckedIncrementERC725Y(uint256 i) internal pure returns (uint256) {\n        unchecked {\n            return i + 1;\n        }\n    }\n\n    /**\n     * @inheritdoc ERC165\n     */\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(IERC165, ERC165) returns (bool) {\n        return interfaceId == _INTERFACEID_ERC725Y || super.supportsInterface(interfaceId);\n    }\n}\n"
    },
    "@erc725/smart-contracts/contracts/errors.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/**\n * @dev reverts when trying to send more native tokens `value` than available in current `balance`.\n * @param balance the balance of the ERC725X contract.\n * @param value the amount of native tokens sent via `ERC725X.execute(...)`.\n */\nerror ERC725X_InsufficientBalance(uint256 balance, uint256 value);\n\n/**\n * @dev reverts when the `operationTypeProvided` is none of the default operation types available.\n * (CALL = 0; CREATE = 1; CREATE2 = 2; STATICCALL = 3; DELEGATECALL = 4)\n */\nerror ERC725X_UnknownOperationType(uint256 operationTypeProvided);\n\n/**\n * @dev the `value` parameter (= sending native tokens) is not allowed when making a staticcall\n * via `ERC725X.execute(...)` because sending native tokens is a state changing operation.\n */\nerror ERC725X_MsgValueDisallowedInStaticCall();\n\n/**\n * @dev the `value` parameter (= sending native tokens) is not allowed when making a delegatecall\n * via `ERC725X.execute(...)` because msg.value is persisting.\n */\nerror ERC725X_MsgValueDisallowedInDelegateCall();\n\n/**\n * @dev reverts when passing a `to` address while deploying a contract va `ERC725X.execute(...)`\n * whether using operation type 1 (CREATE) or 2 (CREATE2).\n */\nerror ERC725X_CreateOperationsRequireEmptyRecipientAddress();\n\n/**\n * @dev reverts when contract deployment via `ERC725X.execute(...)` failed.\n * whether using operation type 1 (CREATE) or 2 (CREATE2).\n */\nerror ERC725X_ContractDeploymentFailed();\n\n/**\n * @dev reverts when no contract bytecode was provided as parameter when trying to deploy a contract\n * via `ERC725X.execute(...)`, whether using operation type 1 (CREATE) or 2 (CREATE2).\n */\nerror ERC725X_NoContractBytecodeProvided();\n\n/**\n * @dev reverts when there is not the same number of operation, to addresses, value, and data.\n */\nerror ERC725X_ExecuteParametersLengthMismatch();\n\n/**\n * @dev reverts when there is not the same number of elements in the lists of data keys and data values\n * when calling setData(bytes32[],bytes[]).\n * @param dataKeysLength the number of data keys in the bytes32[] dataKeys\n * @param dataValuesLength the number of data value in the bytes[] dataValue\n */\nerror ERC725Y_DataKeysValuesLengthMismatch(uint256 dataKeysLength, uint256 dataValuesLength);\n\n/**\n * @dev reverts when sending value to the `setData(..)` functions\n */\nerror ERC725Y_MsgValueDisallowed();\n"
    },
    "@erc725/smart-contracts/contracts/interfaces/IERC725X.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.0;\n\n// interfaces\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @title The interface for ERC725X General executor\n * @dev ERC725X provides the ability to call arbitrary functions at any other smart contract and itself,\n * including using `delegatecall`, `staticcall`, as well as creating contracts using `create` and `create2`\n * This is the basis for a smart contract based account system, but could also be used as a proxy account system\n */\ninterface IERC725X is IERC165 {\n    /**\n     * @notice Emitted when deploying a contract\n     * @param operationType The opcode used to deploy the contract (CREATE or CREATE2)\n     * @param contractAddress The created contract address\n     * @param value The amount of native tokens (in Wei) sent to fund the created contract address\n     */\n    event ContractCreated(\n        uint256 indexed operationType,\n        address indexed contractAddress,\n        uint256 indexed value,\n        bytes32 salt\n    );\n\n    /**\n     * @notice Emitted when calling an address (EOA or contract)\n     * @param operationType The low-level call opcode used to call the `to` address (CALL, STATICALL or DELEGATECALL)\n     * @param target The address to call. `target` will be unused if a contract is created (operation types 1 and 2).\n     * @param value The amount of native tokens transferred with the call (in Wei)\n     * @param selector The first 4 bytes (= function selector) of the data sent with the call\n     */\n    event Executed(\n        uint256 indexed operationType,\n        address indexed target,\n        uint256 indexed value,\n        bytes4 selector\n    );\n\n    /**\n     * @param operationType The operation type used: CALL = 0; CREATE = 1; CREATE2 = 2; STATICCALL = 3; DELEGATECALL = 4\n     * @param target The address of the EOA or smart contract.  (unused if a contract is created via operation type 1 or 2)\n     * @param value The amount of native tokens to transfer (in Wei)\n     * @param data The call data, or the creation bytecode of the contract to deploy\n     *\n     * @dev Generic executor function to:\n     *\n     * - send native tokens to any address.\n     * - interact with any contract by passing an abi-encoded function call in the `data` parameter.\n     * - deploy a contract by providing its creation bytecode in the `data` parameter.\n     *\n     * Requirements:\n     *\n     * - SHOULD only be callable by the owner of the contract set via ERC173.\n     * - if a `value` is provided, the contract MUST have at least this amount in its balance to execute successfully.\n     * - if the operation type is STATICCALL or DELEGATECALL, `value` SHOULD be 0.\n     * - `target` SHOULD be address(0) when deploying a contract.\n     *\n     * Emits an {Executed} event, when a call is made with `operationType` 0 (CALL), 3 (STATICCALL) or 4 (DELEGATECALL)\n     * Emits a {ContractCreated} event, when deploying a contract with `operationType` 1 (CREATE) or 2 (CREATE2)\n     */\n    function execute(\n        uint256 operationType,\n        address target,\n        uint256 value,\n        bytes memory data\n    ) external payable returns (bytes memory);\n\n    /**\n     * @param operationsType The list of operations type used: CALL = 0; CREATE = 1; CREATE2 = 2; STATICCALL = 3; DELEGATECALL = 4\n     * @param targets The list of addresses to call. `targets` will be unused if a contract is created (operation types 1 and 2).\n     * @param values The list of native token amounts to transfer (in Wei)\n     * @param datas The list of call data, or the creation bytecode of the contract to deploy\n     *\n     * @dev Generic batch executor function to:\n     *\n     * - send native tokens to any address.\n     * - interact with any contract by passing an abi-encoded function call in the `datas` parameter.\n     * - deploy a contract by providing its creation bytecode in the `datas` parameter.\n     *\n     * Requirements:\n     *\n     * - The length of the parameters provided MUST be equal\n     * - SHOULD only be callable by the owner of the contract set via ERC173.\n     * - if a `values` is provided, the contract MUST have at least this amount in its balance to execute successfully.\n     * - if the operation type is STATICCALL or DELEGATECALL, `values` SHOULD be 0.\n     * - `targets` SHOULD be address(0) when deploying a contract.\n     *\n     * Emits an {Executed} event, when a call is made with `operationType` 0 (CALL), 3 (STATICCALL) or 4 (DELEGATECALL)\n     * Emits a {ContractCreated} event, when deploying a contract with `operationType` 1 (CREATE) or 2 (CREATE2)\n     */\n    function execute(\n        uint256[] memory operationsType,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory datas\n    ) external payable returns (bytes[] memory);\n}\n"
    },
    "@erc725/smart-contracts/contracts/interfaces/IERC725Y.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.0;\n\n// interfaces\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @title The interface for ERC725Y General data key/value store\n * @dev ERC725Y provides the ability to set arbitrary data key/value pairs that can be changed over time\n * It is intended to standardise certain data key/value pairs to allow automated read and writes\n * from/to the contract storage\n */\ninterface IERC725Y is IERC165 {\n    /**\n     * @notice Emitted when data at a key is changed\n     * @param dataKey The data key which data value is set\n     * @param dataValue The data value to set\n     */\n    event DataChanged(bytes32 indexed dataKey, bytes dataValue);\n\n    /**\n     * @notice Gets singular data at a given `dataKey`\n     * @param dataKey The key which value to retrieve\n     * @return dataValue The data stored at the key\n     */\n    function getData(bytes32 dataKey) external view returns (bytes memory dataValue);\n\n    /**\n     * @notice Gets array of data for multiple given keys\n     * @param dataKeys The array of keys which values to retrieve\n     * @return dataValues The array of data stored at multiple keys\n     */\n    function getData(bytes32[] memory dataKeys) external view returns (bytes[] memory dataValues);\n\n    /**\n     * @notice Sets singular data for a given `dataKey`\n     * @param dataKey The key to retrieve stored value\n     * @param dataValue The value to set\n     * SHOULD only be callable by the owner of the contract set via ERC173\n     *\n     * The function is marked as payable to enable flexibility on child contracts\n     *\n     * If the function is not intended to receive value, an additional check\n     * should be implemented to check that value equal 0.\n     *\n     * Emits a {DataChanged} event.\n     */\n    function setData(bytes32 dataKey, bytes memory dataValue) external payable;\n\n    /**\n     * @param dataKeys The array of data keys for values to set\n     * @param dataValues The array of values to set\n     * @dev Sets array of data for multiple given `dataKeys`\n     * SHOULD only be callable by the owner of the contract set via ERC173\n     *\n     * The function is marked as payable to enable flexibility on child contracts\n     *\n     * If the function is not intended to receive value, an additional check\n     * should be implemented to check that value equal 0.\n     *\n     * Emits a {DataChanged} event.\n     */\n    function setData(bytes32[] memory dataKeys, bytes[] memory dataValues) external payable;\n}\n"
    },
    "@lukso/lsp-smart-contracts/contracts/Custom/EIP191Signer.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.5;\n\nlibrary EIP191Signer {\n    function toDataWithIntendedValidator(address validator, bytes memory dataToSign)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, dataToSign));\n    }\n}\n"
    },
    "@lukso/lsp-smart-contracts/contracts/LSP0ERC725Account/LSP0Constants.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.4;\n\n// --- ERC165 interface ids\nbytes4 constant _INTERFACEID_LSP0 = 0x66767497;\nbytes4 constant _INTERFACEID_ERC1271 = 0x1626ba7e;\n\n// ERC1271 - Standard Signature Validation\nbytes4 constant _ERC1271_MAGICVALUE = 0x1626ba7e;\nbytes4 constant _ERC1271_FAILVALUE = 0xffffffff;\n\n// Ownerhsip Transfer Type IDs\n\n// keccak256('LSP0OwnershipTransferStarted')\nbytes32 constant _TYPEID_LSP0_OwnershipTransferStarted = 0xe17117c9d2665d1dbeb479ed8058bbebde3c50ac50e2e65619f60006caac6926;\n\n// keccak256('LSP0OwnershipTransferred_SenderNotification')\nbytes32 constant _TYPEID_LSP0_OwnershipTransferred_SenderNotification = 0xa4e59c931d14f7c8a7a35027f92ee40b5f2886b9fdcdb78f30bc5ecce5a2f814;\n\n// keccak256('LSP0OwnershipTransferred_RecipientNotification')\nbytes32 constant _TYPEID_LSP0_OwnershipTransferred_RecipientNotification = 0xceca317f109c43507871523e82dc2a3cc64dfa18f12da0b6db14f6e23f995538;\n"
    },
    "@lukso/lsp-smart-contracts/contracts/LSP0ERC725Account/LSP0ERC725Account.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.4;\n\n// modules\nimport {LSP0ERC725AccountCore} from \"./LSP0ERC725AccountCore.sol\";\nimport {OwnableUnset} from \"@erc725/smart-contracts/contracts/custom/OwnableUnset.sol\";\n\n/**\n * @title Implementation of ERC725Account\n * @author Fabian Vogelsteller <fabian@lukso.network>, Jean Cavallera (CJ42), Yamen Merhi (YamenMerhi)\n * @dev Bundles ERC725X and ERC725Y, ERC1271 and LSP1UniversalReceiver and allows receiving native tokens\n */\ncontract LSP0ERC725Account is LSP0ERC725AccountCore {\n    /**\n     * @notice Sets the owner of the contract\n     * @param newOwner the owner of the contract\n     */\n    constructor(address newOwner) payable {\n        if (msg.value != 0) emit ValueReceived(msg.sender, msg.value);\n        OwnableUnset._setOwner(newOwner);\n    }\n}\n"
    },
    "@lukso/lsp-smart-contracts/contracts/LSP0ERC725Account/LSP0ERC725AccountCore.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.4;\n\n// interfaces\nimport {IERC1271} from \"@openzeppelin/contracts/interfaces/IERC1271.sol\";\nimport {ILSP1UniversalReceiver} from \"../LSP1UniversalReceiver/ILSP1UniversalReceiver.sol\";\n\n// libraries\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {ERC165Checker} from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {LSP1Utils} from \"../LSP1UniversalReceiver/LSP1Utils.sol\";\nimport {LSP2Utils} from \"../LSP2ERC725YJSONSchema/LSP2Utils.sol\";\n\n// modules\nimport {ERC725YCore} from \"@erc725/smart-contracts/contracts/ERC725YCore.sol\";\nimport {ERC725XCore} from \"@erc725/smart-contracts/contracts/ERC725XCore.sol\";\nimport {OwnableUnset} from \"@erc725/smart-contracts/contracts/custom/OwnableUnset.sol\";\nimport {LSP14Ownable2Step} from \"../LSP14Ownable2Step/LSP14Ownable2Step.sol\";\nimport {LSP17Extendable} from \"../LSP17ContractExtension/LSP17Extendable.sol\";\n\n// constants\nimport \"@erc725/smart-contracts/contracts/constants.sol\";\nimport \"@erc725/smart-contracts/contracts/errors.sol\";\nimport {\n    _INTERFACEID_LSP0,\n    _INTERFACEID_ERC1271,\n    _ERC1271_MAGICVALUE,\n    _ERC1271_FAILVALUE,\n    _TYPEID_LSP0_OwnershipTransferStarted,\n    _TYPEID_LSP0_OwnershipTransferred_SenderNotification,\n    _TYPEID_LSP0_OwnershipTransferred_RecipientNotification\n} from \"../LSP0ERC725Account/LSP0Constants.sol\";\nimport {\n    _INTERFACEID_LSP1,\n    _LSP1_UNIVERSAL_RECEIVER_DELEGATE_PREFIX,\n    _LSP1_UNIVERSAL_RECEIVER_DELEGATE_KEY\n} from \"../LSP1UniversalReceiver/LSP1Constants.sol\";\nimport {_INTERFACEID_LSP14} from \"../LSP14Ownable2Step/LSP14Constants.sol\";\n\nimport {_LSP17_EXTENSION_PREFIX} from \"../LSP17ContractExtension/LSP17Constants.sol\";\n\n/**\n * @title Core Implementation of ERC725Account\n * @author Fabian Vogelsteller <fabian@lukso.network>, Jean Cavallera (CJ42), Yamen Merhi (YamenMerhi)\n * @dev Bundles ERC725X and ERC725Y, ERC1271 and LSP1UniversalReceiver and allows receiving native tokens\n */\nabstract contract LSP0ERC725AccountCore is\n    ERC725XCore,\n    ERC725YCore,\n    LSP14Ownable2Step,\n    LSP17Extendable,\n    IERC1271,\n    ILSP1UniversalReceiver\n{\n    using ERC165Checker for address;\n    using LSP1Utils for address;\n    using Address for address;\n\n    /**\n     * @notice Emitted when receiving native tokens\n     * @param sender The address of the sender\n     * @param value The amount of native tokens received\n     */\n    event ValueReceived(address indexed sender, uint256 indexed value);\n\n    /**\n     * @dev Emits an event when receiving native tokens\n     *\n     * Executed when receiving native tokens with empty calldata.\n     */\n    receive() external payable virtual {\n        if (msg.value != 0) emit ValueReceived(msg.sender, msg.value);\n    }\n\n    /**\n     * @dev Returns the extension stored under the `_LSP17_EXTENSION_PREFIX` data key\n     * mapped to the functionSelector provided.\n     *\n     * If no extension is stored, returns the address(0)\n     */\n    function _getExtension(bytes4 functionSelector)\n        internal\n        view\n        virtual\n        override\n        returns (address)\n    {\n        bytes32 mappedExtensionDataKey = LSP2Utils.generateMappingKey(\n            _LSP17_EXTENSION_PREFIX,\n            functionSelector\n        );\n\n        // Check if there is an extension for the function selector provided\n        address extension = address(bytes20(_getData(mappedExtensionDataKey)));\n\n        return extension;\n    }\n\n    // solhint-disable no-complex-fallback\n\n    /**\n     * @dev Emits an event when receiving native tokens\n     *\n     * Forwards the call to an extension contract (address). This address can be retrieved from\n     * the ERC725Y data key-value store using the data key below (function selector appended to the prefix):\n     *_LSP17_FALLBACK_EXTENSIONS_HANDLER_ + <function-selector>\n     * If there is no extension stored under the data key, return.\n     *\n     * The call to the extension is appended with bytes20 (msg.sender) and bytes32 (msg.value).\n     * Returns the return value on success and revert in case of failure.\n     *\n     * If the msg.data is shorter than 4 bytes or the first 4 bytes are 0s\n     * do not check for an extension and return\n     *\n     * Executed when:\n     * - the first 4 bytes of the calldata do not match any publicly callable functions from the contract ABI.\n     * - receiving native tokens with some calldata.\n     */\n    fallback() external payable virtual {\n        if (msg.value != 0) emit ValueReceived(msg.sender, msg.value);\n        if (msg.data.length < 4 || msg.sig == bytes4(0)) return;\n\n        _fallbackLSP17Extendable();\n    }\n\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`.\n     *\n     * If the contract doesn't support the `interfaceId`, it forwards the call to the\n     * `supportsInterface` extension according to LSP17, and checks if the extension\n     * implements the interface defined by `interfaceId`.\n     */\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC725XCore, ERC725YCore, LSP17Extendable)\n        returns (bool)\n    {\n        return\n            interfaceId == _INTERFACEID_ERC1271 ||\n            interfaceId == _INTERFACEID_LSP0 ||\n            interfaceId == _INTERFACEID_LSP1 ||\n            interfaceId == _INTERFACEID_LSP14 ||\n            super.supportsInterface(interfaceId) ||\n            _supportsInterfaceInERC165Extension(interfaceId);\n    }\n\n    /**\n     * @notice Checks if an owner signed `_data`.\n     * ERC1271 interface.\n     *\n     * @param dataHash hash of the data signed//Arbitrary length data signed on the behalf of address(this)\n     * @param signature owner's signature(s) of the data\n     */\n    function isValidSignature(bytes32 dataHash, bytes memory signature)\n        public\n        view\n        virtual\n        returns (bytes4 magicValue)\n    {\n        address _owner = owner();\n\n        // If owner is a contract\n        if (_owner.code.length > 0) {\n            (bool success, bytes memory result) = _owner.staticcall(\n                abi.encodeWithSelector(IERC1271.isValidSignature.selector, dataHash, signature)\n            );\n\n            bool isValid = (success &&\n                result.length == 32 &&\n                abi.decode(result, (bytes32)) == bytes32(_ERC1271_MAGICVALUE));\n\n            return isValid ? _ERC1271_MAGICVALUE : _ERC1271_FAILVALUE;\n        }\n        // If owner is an EOA\n        else {\n            return\n                _owner == ECDSA.recover(dataHash, signature)\n                    ? _ERC1271_MAGICVALUE\n                    : _ERC1271_FAILVALUE;\n        }\n    }\n\n    /**\n     * @param operationType The operation to execute: CALL = 0 CREATE = 1 CREATE2 = 2 STATICCALL = 3 DELEGATECALL = 4\n     * @param target The smart contract or address to interact with, `to` will be unused if a contract is created (operation 1 and 2)\n     * @param value The amount of native tokens to transfer (in Wei).\n     * @param data The call data, or the bytecode of the contract to deploy\n     * @dev Executes any other smart contract.\n     * SHOULD only be callable by the owner of the contract set via ERC173\n     *\n     * Emits a {Executed} event, when a call is executed under `operationType` 0, 3 and 4\n     * Emits a {ContractCreated} event, when a contract is created under `operationType` 1 and 2\n     * Emits a {ValueReceived} event, when receives native token\n     */\n    function execute(\n        uint256 operationType,\n        address target,\n        uint256 value,\n        bytes memory data\n    ) public payable virtual override onlyOwner returns (bytes memory) {\n        if (msg.value != 0) emit ValueReceived(msg.sender, msg.value);\n        return _execute(operationType, target, value, data);\n    }\n\n    /**\n     * @inheritdoc ERC725XCore\n     *\n     * @dev Emits a {ValueReceived} event when receiving native tokens.\n     */\n    function execute(\n        uint256[] memory operationsType,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory datas\n    ) public payable virtual override onlyOwner returns (bytes[] memory) {\n        if (msg.value != 0) emit ValueReceived(msg.sender, msg.value);\n        return _execute(operationsType, targets, values, datas);\n    }\n\n    /**\n     * @notice Triggers the UniversalReceiver event when this function gets executed successfully.\n     * Forwards the call to the addresses stored in the ERC725Y storage under the LSP1UniversalReceiverDelegate\n     * Key and the typeId Key (param) respectively. The call will be discarded if no addresses were set.\n     *\n     * @param typeId The type of call received.\n     * @param receivedData The data received.\n     * @return returnedValues The ABI encoded return value of the LSP1UniversalReceiverDelegate call\n     * and the LSP1TypeIdDelegate call.\n     */\n    function universalReceiver(bytes32 typeId, bytes calldata receivedData)\n        public\n        payable\n        virtual\n        returns (bytes memory returnedValues)\n    {\n        if (msg.value != 0) emit ValueReceived(msg.sender, msg.value);\n        bytes memory lsp1DelegateValue = _getData(_LSP1_UNIVERSAL_RECEIVER_DELEGATE_KEY);\n        bytes memory resultDefaultDelegate;\n\n        if (lsp1DelegateValue.length >= 20) {\n            address universalReceiverDelegate = address(bytes20(lsp1DelegateValue));\n\n            if (universalReceiverDelegate.supportsERC165InterfaceUnchecked(_INTERFACEID_LSP1)) {\n                resultDefaultDelegate = universalReceiverDelegate\n                    .callUniversalReceiverWithCallerInfos(\n                        typeId,\n                        receivedData,\n                        msg.sender,\n                        msg.value\n                    );\n            }\n        }\n\n        bytes32 lsp1typeIdDelegateKey = LSP2Utils.generateMappingKey(\n            _LSP1_UNIVERSAL_RECEIVER_DELEGATE_PREFIX,\n            bytes20(typeId)\n        );\n\n        bytes memory lsp1TypeIdDelegateValue = _getData(lsp1typeIdDelegateKey);\n        bytes memory resultTypeIdDelegate;\n\n        if (lsp1TypeIdDelegateValue.length >= 20) {\n            address universalReceiverDelegate = address(bytes20(lsp1TypeIdDelegateValue));\n\n            if (universalReceiverDelegate.supportsERC165InterfaceUnchecked(_INTERFACEID_LSP1)) {\n                resultTypeIdDelegate = universalReceiverDelegate\n                    .callUniversalReceiverWithCallerInfos(\n                        typeId,\n                        receivedData,\n                        msg.sender,\n                        msg.value\n                    );\n            }\n        }\n\n        returnedValues = abi.encode(resultDefaultDelegate, resultTypeIdDelegate);\n        emit UniversalReceiver(msg.sender, msg.value, typeId, receivedData, returnedValues);\n    }\n\n    /**\n     * @dev Sets the pending owner and notifies the pending owner\n     *\n     * @param _newOwner The address nofied and set as `pendingOwner`\n     */\n    function transferOwnership(address _newOwner)\n        public\n        virtual\n        override(LSP14Ownable2Step, OwnableUnset)\n        onlyOwner\n    {\n        LSP14Ownable2Step._transferOwnership(_newOwner);\n    }\n\n    /**\n     * @dev Renounce ownership of the contract in a 2-step process\n     */\n    function renounceOwnership()\n        public\n        virtual\n        override(LSP14Ownable2Step, OwnableUnset)\n        onlyOwner\n    {\n        LSP14Ownable2Step._renounceOwnership();\n    }\n\n    /**\n     * @dev SAVE GAS by emitting the DataChanged event with only the first 256 bytes of dataValue\n     */\n    function _setData(bytes32 dataKey, bytes memory dataValue) internal virtual override {\n        _store[dataKey] = dataValue;\n        emit DataChanged(\n            dataKey,\n            dataValue.length <= 256 ? dataValue : BytesLib.slice(dataValue, 0, 256)\n        );\n    }\n\n    // --- LSP14 URD Hooks\n\n    /**\n     * @dev Calls the universalReceiver function of the sender when ownerhsip transfer starts\n     * if supports LSP1 InterfaceId\n     */\n    function _notifyLSP1SenderOnOwnershipTransferStart(address notifiedContract, bytes memory data)\n        internal\n        virtual\n        override\n    {\n        if (ERC165Checker.supportsERC165InterfaceUnchecked(notifiedContract, _INTERFACEID_LSP1)) {\n            ILSP1UniversalReceiver(notifiedContract).universalReceiver(\n                _TYPEID_LSP0_OwnershipTransferStarted,\n                data\n            );\n        }\n    }\n\n    /**\n     * @dev Calls the universalReceiver function of the sender when ownerhsip transfer is complete\n     * if supports LSP1 InterfaceId\n     */\n    function _notifyLSP1SenderOnOwnershipTransferCompletion(\n        address notifiedContract,\n        bytes memory data\n    ) internal virtual override {\n        if (ERC165Checker.supportsERC165InterfaceUnchecked(notifiedContract, _INTERFACEID_LSP1)) {\n            ILSP1UniversalReceiver(notifiedContract).universalReceiver(\n                _TYPEID_LSP0_OwnershipTransferred_SenderNotification,\n                data\n            );\n        }\n    }\n\n    /**\n     * @dev Calls the universalReceiver function of the recipient when ownerhsip transfer is complete\n     * if supports LSP1 InterfaceId\n     */\n    function _notifyLSP1RecipientOnOwnershipTransferCompletion(\n        address notifiedContract,\n        bytes memory data\n    ) internal virtual override {\n        if (ERC165Checker.supportsERC165InterfaceUnchecked(notifiedContract, _INTERFACEID_LSP1)) {\n            ILSP1UniversalReceiver(notifiedContract).universalReceiver(\n                _TYPEID_LSP0_OwnershipTransferred_RecipientNotification,\n                data\n            );\n        }\n    }\n}\n"
    },
    "@lukso/lsp-smart-contracts/contracts/LSP10ReceivedVaults/LSP10Constants.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.4;\n\n// --- ERC725Y Data Keys\n\n// keccak256('LSP10Vaults[]')\nbytes32 constant _LSP10_VAULTS_ARRAY_KEY = 0x55482936e01da86729a45d2b87a6b1d3bc582bea0ec00e38bdb340e3af6f9f06;\n\n// bytes10(keccak256('LSP10VaultsMap'))\nbytes10 constant _LSP10_VAULTS_MAP_KEY_PREFIX = 0x192448c3c0f88c7f238c;\n"
    },
    "@lukso/lsp-smart-contracts/contracts/LSP14Ownable2Step/ILSP14Ownable2Step.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @dev Extended version of Ownable (EIP173) in which, transferring or renouncing ownership\n * of the contract works in 2 steps.\n */\ninterface ILSP14Ownable2Step {\n    /**\n     * @dev emitted when starting the `transferOwnership(..)` 2-step process.\n     */\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @inheritdoc OwnableUnset\n     * event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n     */\n\n    /**\n     * @dev emitted when starting the `renounceOwnership(..)` 2-step process.\n     */\n    event RenounceOwnershipStarted();\n\n    /**\n     * @dev emitted when the ownership of the contract has been renounced.\n     */\n    event OwnershipRenounced();\n\n    /**\n     * @inheritdoc OwnableUnset\n     * function owner() external view returns (address);\n     */\n\n    /**\n     * @dev Returns the address of the current pending owner.\n     */\n    function pendingOwner() external view returns (address);\n\n    /**\n     * @dev Initiate the process of transferring ownership of the contract by setting the pending owner.\n     */\n    function transferOwnership(address newOwner) external;\n\n    /**\n     * @dev Complete the process of transferring ownership. MUST be called by the pendingOwner.\n     */\n    function acceptOwnership() external;\n\n    /**\n     * @dev Initiate the process of renouncing ownerhsip on the first call and confirm the renouncement of the ownership on the second call.\n     */\n    function renounceOwnership() external;\n}\n"
    },
    "@lukso/lsp-smart-contracts/contracts/LSP14Ownable2Step/LSP14Constants.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nbytes4 constant _INTERFACEID_LSP14 = 0x94be5999;\n\n// --- Type IDs\n\n// keccak256('LSP14OwnershipTransferStarted')\nbytes32 constant _TYPEID_LSP14_OwnershipTransferStarted = 0xee9a7c0924f740a2ca33d59b7f0c2929821ea9837ce043ce91c1823e9c4e52c0;\n\n// keccak256('LSP14OwnershipTransferred_SenderNotification')\nbytes32 constant _TYPEID_LSP14_OwnershipTransferred_SenderNotification = 0xa124442e1cc7b52d8e2ede2787d43527dc1f3ae0de87f50dd03e27a71834f74c;\n\n// keccak256('LSP14OwnershipTransferred_RecipientNotification')\nbytes32 constant _TYPEID_LSP14_OwnershipTransferred_RecipientNotification = 0xe32c7debcb817925ba4883fdbfc52797187f28f73f860641dab1a68d9b32902c;\n"
    },
    "@lukso/lsp-smart-contracts/contracts/LSP14Ownable2Step/LSP14Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @dev reverts when trying to renounce ownership before the initial confirmation delay\n */\nerror NotInRenounceOwnershipInterval(uint256 renounceOwnershipStart, uint256 renounceOwnershipEnd);\n\n/**\n * @dev reverts when trying to transfer ownership to the address(this)\n */\nerror CannotTransferOwnershipToSelf();\n"
    },
    "@lukso/lsp-smart-contracts/contracts/LSP14Ownable2Step/LSP14Ownable2Step.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n// interfaces\nimport {ILSP14Ownable2Step} from \"./ILSP14Ownable2Step.sol\";\nimport {ILSP1UniversalReceiver} from \"../LSP1UniversalReceiver/ILSP1UniversalReceiver.sol\";\n\n// modules\nimport {OwnableUnset} from \"@erc725/smart-contracts/contracts/custom/OwnableUnset.sol\";\nimport {ERC165Checker} from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\n// errors\nimport \"./LSP14Errors.sol\";\n\n// constants\nimport {\n    _TYPEID_LSP14_OwnershipTransferStarted,\n    _TYPEID_LSP14_OwnershipTransferred_SenderNotification,\n    _TYPEID_LSP14_OwnershipTransferred_RecipientNotification\n} from \"./LSP14Constants.sol\";\nimport {_INTERFACEID_LSP1} from \"../LSP1UniversalReceiver/LSP1Constants.sol\";\n\n/**\n * @title LSP14Ownable2Step\n * @author Fabian Vogelsteller <fabian@lukso.network>, Jean Cavallera (CJ42), Yamen Merhi (YamenMerhi), Daniel Afteni (B00ste)\n * @dev This contract is a modified version of the OwnableUnset implementation, where transferring and renouncing ownership\n *      works as a 2 steps process. This can be used as a confirmation mechanism to prevent potential mistakes when\n *      transferring ownership of the contract, where the control of the contract could be lost forever.\n */\nabstract contract LSP14Ownable2Step is ILSP14Ownable2Step, OwnableUnset {\n    /**\n     * @dev The number of block that MUST pass before one is able to\n     *  confirm renouncing ownership\n     */\n    uint256 public constant RENOUNCE_OWNERSHIP_CONFIRMATION_DELAY = 100;\n\n    /**\n     * @dev The number of blocks during which one can renounce ownership\n     */\n    uint256 public constant RENOUNCE_OWNERSHIP_CONFIRMATION_PERIOD = 100;\n\n    /**\n     * @dev The block number saved when initiating the process of\n     * renouncing ownerhsip\n     */\n    uint256 private _renounceOwnershipStartedAt;\n\n    /**\n     * @dev The address that ownership of the contract is transferred to.\n     * This address may use `acceptOwnership()` to gain ownership of the contract.\n     * Meaning that the current owner will lose access to the methods marked as\n     * `onlyOwner` in favor to the `_pendingOwner`.\n     */\n    address private _pendingOwner;\n\n    // --- General Methods\n\n    /**\n     * @inheritdoc ILSP14Ownable2Step\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @inheritdoc ILSP14Ownable2Step\n     */\n    function transferOwnership(address newOwner)\n        public\n        virtual\n        override(OwnableUnset, ILSP14Ownable2Step)\n        onlyOwner\n    {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @inheritdoc ILSP14Ownable2Step\n     */\n    function acceptOwnership() public virtual {\n        _acceptOwnership();\n    }\n\n    /**\n     * @inheritdoc ILSP14Ownable2Step\n     */\n    function renounceOwnership()\n        public\n        virtual\n        override(OwnableUnset, ILSP14Ownable2Step)\n        onlyOwner\n    {\n        _renounceOwnership();\n    }\n\n    // --- Internal methods\n\n    /**\n     * @dev Start the process of transferring ownership of the contract\n     * and notify the new owner about it.\n     *\n     * Requirements:\n     * - `newOwner` MUST NOT accept ownership of the contract in the same transaction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        if (newOwner == address(this)) revert CannotTransferOwnershipToSelf();\n\n        _pendingOwner = newOwner;\n        delete _renounceOwnershipStartedAt;\n        address currentOwner = owner();\n        emit OwnershipTransferStarted(currentOwner, newOwner);\n\n        _notifyLSP1SenderOnOwnershipTransferStart(newOwner, \"\");\n        require(\n            currentOwner == owner(),\n            \"LSP14: newOwner MUST accept ownership in a separate transaction\"\n        );\n    }\n\n    /**\n     * @dev Accept ownership of the contract and notify\n     * previous owner and the new owner that ownership has been transferred.\n     */\n    function _acceptOwnership() internal virtual {\n        require(msg.sender == pendingOwner(), \"LSP14: caller is not the pendingOwner\");\n\n        address previousOwner = owner();\n        _setOwner(msg.sender);\n        delete _pendingOwner;\n\n        _notifyLSP1SenderOnOwnershipTransferCompletion(previousOwner, \"\");\n        _notifyLSP1RecipientOnOwnershipTransferCompletion(msg.sender, \"\");\n    }\n\n    /**\n     * @dev initiate or confirm the process of renouncing ownership. Leaves the contract\n     * without an owner, making functions marked as `onlyOwner` not callable anymore.\n     */\n    function _renounceOwnership() internal virtual {\n        uint256 currentBlock = block.number;\n        uint256 confirmationPeriodStart = _renounceOwnershipStartedAt +\n            RENOUNCE_OWNERSHIP_CONFIRMATION_DELAY;\n        uint256 confirmationPeriodEnd = confirmationPeriodStart +\n            RENOUNCE_OWNERSHIP_CONFIRMATION_PERIOD;\n\n        if (currentBlock > confirmationPeriodEnd) {\n            _renounceOwnershipStartedAt = currentBlock;\n            delete _pendingOwner;\n            emit RenounceOwnershipStarted();\n            return;\n        }\n\n        if (currentBlock < confirmationPeriodStart) {\n            revert NotInRenounceOwnershipInterval(confirmationPeriodStart, confirmationPeriodEnd);\n        }\n\n        _setOwner(address(0));\n        delete _renounceOwnershipStartedAt;\n        delete _pendingOwner;\n        emit OwnershipRenounced();\n    }\n\n    // --- URD Hooks\n\n    /**\n     * @dev Calls the universalReceiver function of the sender when ownership transfer starts\n     * if supports LSP1 InterfaceId\n     */\n    function _notifyLSP1SenderOnOwnershipTransferStart(address notifiedContract, bytes memory data)\n        internal\n        virtual\n    {\n        if (ERC165Checker.supportsERC165InterfaceUnchecked(notifiedContract, _INTERFACEID_LSP1)) {\n            ILSP1UniversalReceiver(notifiedContract).universalReceiver(\n                _TYPEID_LSP14_OwnershipTransferStarted,\n                data\n            );\n        }\n    }\n\n    /**\n     * @dev Calls the universalReceiver function of the sender when ownerhsip transfer is complete\n     * if supports LSP1 InterfaceId\n     */\n    function _notifyLSP1SenderOnOwnershipTransferCompletion(\n        address notifiedContract,\n        bytes memory data\n    ) internal virtual {\n        if (ERC165Checker.supportsERC165InterfaceUnchecked(notifiedContract, _INTERFACEID_LSP1)) {\n            ILSP1UniversalReceiver(notifiedContract).universalReceiver(\n                _TYPEID_LSP14_OwnershipTransferred_SenderNotification,\n                data\n            );\n        }\n    }\n\n    /**\n     * @dev Calls the universalReceiver function of the recipient when ownerhsip transfer is complete\n     * if supports LSP1 InterfaceId\n     */\n    function _notifyLSP1RecipientOnOwnershipTransferCompletion(\n        address notifiedContract,\n        bytes memory data\n    ) internal virtual {\n        if (ERC165Checker.supportsERC165InterfaceUnchecked(notifiedContract, _INTERFACEID_LSP1)) {\n            ILSP1UniversalReceiver(notifiedContract).universalReceiver(\n                _TYPEID_LSP14_OwnershipTransferred_RecipientNotification,\n                data\n            );\n        }\n    }\n}\n"
    },
    "@lukso/lsp-smart-contracts/contracts/LSP17ContractExtension/LSP17Constants.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.4;\n\n// --- ERC165 interface ids\n\n// bytes4(keccack256(\"LSP17Extendable\"))\nbytes4 constant _INTERFACEID_LSP17_EXTENDABLE = 0xa918fa6b;\n\n// bytes4(keccack256(\"LSP17Extension\"))\nbytes4 constant _INTERFACEID_LSP17_EXTENSION = 0xcee78b40;\n\n// --- ERC725Y Data Keys\n\n// Extension Handler Prefix\n\n// bytes10(keccak256('LSP17Extension'))\nbytes10 constant _LSP17_EXTENSION_PREFIX = 0xcee78b4094da86011096;\n"
    },
    "@lukso/lsp-smart-contracts/contracts/LSP17ContractExtension/LSP17Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @dev reverts when there is no extension for the function selector being called with\n */\nerror NoExtensionFoundForFunctionSelector(bytes4 functionSelector);\n"
    },
    "@lukso/lsp-smart-contracts/contracts/LSP17ContractExtension/LSP17Extendable.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.4;\n\n// modules\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport {ERC165Checker} from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\n// constants\nimport {_INTERFACEID_LSP17_EXTENDABLE} from \"./LSP17Constants.sol\";\n\n// errors\nimport \"./LSP17Errors.sol\";\n\n/**\n * @title Implementation of the fallback logic according to LSP17ContractExtension\n * @dev Module to be inherited used to extend the functionality of the parent contract when\n * calling a function that doesn't exist on the parent contract via forwarding the call\n * to an extension mapped to the function selector being called, set originally by the parent contract\n */\nabstract contract LSP17Extendable is ERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == _INTERFACEID_LSP17_EXTENDABLE || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns whether the interfaceId being checked is supported in the extension of the\n     * {supportsInterface} selector.\n     *\n     * To be used by extendable contracts wishing to extend the ERC165 interfaceIds originally\n     * supported by reading whether the interfaceId queried is supported in the `supportsInterface`\n     * extension if the extension is set, if not it returns false.\n     */\n    function _supportsInterfaceInERC165Extension(bytes4 interfaceId)\n        internal\n        view\n        virtual\n        returns (bool)\n    {\n        address erc165Extension = _getExtension(ERC165.supportsInterface.selector);\n        if (erc165Extension == address(0)) return false;\n\n        return ERC165Checker.supportsERC165InterfaceUnchecked(erc165Extension, interfaceId);\n    }\n\n    /**\n     * @dev Returns the extension mapped to a specific function selector\n     * If no extension was found, return the address(0)\n     * To be overrided.\n     * Up to the implementor contract to return an extension based on a function selector\n     */\n    function _getExtension(bytes4 functionSelector) internal view virtual returns (address);\n\n    /**\n     * @dev Forwards the call to an extension mapped to a function selector. If no extension address\n     * is mapped to the function selector (address(0)), then revert.\n     *\n     * The call to the extension is appended with bytes20 (msg.sender) and bytes32 (msg.value).\n     * Returns the return value on success and revert in case of failure.\n     *\n     * As the function uses assembly {return()/revert()} to terminate the call, it cannot be\n     * called before other codes in fallback().\n     *\n     * Otherwise, the codes after _fallbackLSP17Extendable() may never be reached.\n     */\n    function _fallbackLSP17Extendable() internal virtual {\n        // If there is a function selector\n        address extension = _getExtension(msg.sig);\n\n        // if no extension was found, revert\n        if (extension == address(0)) revert NoExtensionFoundForFunctionSelector(msg.sig);\n\n        // solhint-disable no-inline-assembly\n        // if the extension was found, call the extension with the msg.data\n        // appended with bytes20(address) and bytes32(msg.value)\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n\n            // The msg.sender address is shifted to the left by 12 bytes to remove the padding\n            // Then the address without padding is stored right after the calldata\n            mstore(calldatasize(), shl(96, caller()))\n\n            // The msg.value is stored right after the calldata + msg.sender\n            mstore(add(calldatasize(), 20), callvalue())\n\n            // Add 52 bytes for the msg.sender and msg.value appended at the end of the calldata\n            let success := call(gas(), extension, 0, 0, add(calldatasize(), 52), 0, 0)\n\n            // Copy the returned data\n            returndatacopy(0, 0, returndatasize())\n\n            switch success\n            // call returns 0 on failed calls\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n}\n"
    },
    "@lukso/lsp-smart-contracts/contracts/LSP1UniversalReceiver/ILSP1UniversalReceiver.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.4;\n\n/**\n * @title The interface for LSP1UniversalReceiver\n * @dev LSP1UniversalReceiver allows to receive arbitrary messages and to be informed when assets are sent or received\n */\ninterface ILSP1UniversalReceiver {\n    /**\n     * @notice Emitted when the universalReceiver function is succesfully executed\n     * @param from The address calling the universalReceiver function\n     * @param value The amount sent to the universalReceiver function\n     * @param typeId The hash of a specific standard or a hook\n     * @param receivedData The arbitrary data passed to universalReceiver function\n     * @param returnedValue The value returned by the universalReceiver function\n     */\n    event UniversalReceiver(\n        address indexed from,\n        uint256 indexed value,\n        bytes32 indexed typeId,\n        bytes receivedData,\n        bytes returnedValue\n    );\n\n    /**\n     * @param typeId The hash of a specific standard or a hook\n     * @param data The arbitrary data received with the call\n     * @dev Emits an event when it's succesfully executed\n     *\n     * Call the universalReceiverDelegate function in the UniversalReceiverDelegate (URD) contract, if the address of the URD\n     * was set as a value for the `_UniversalReceiverKey` in the account key/value value store of the same contract implementing\n     * the universalReceiver function and if the URD contract has the LSP1UniversalReceiverDelegate Interface Id registred using ERC165\n     *\n     * Emits a {UniversalReceiver} event\n     */\n    function universalReceiver(bytes32 typeId, bytes calldata data)\n        external\n        payable\n        returns (bytes memory);\n}\n"
    },
    "@lukso/lsp-smart-contracts/contracts/LSP1UniversalReceiver/LSP1Constants.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.4;\n\n// --- ERC165 interface ids\nbytes4 constant _INTERFACEID_LSP1 = 0x6bb56a14;\n\n// --- ERC725Y Data Keys\n\n// bytes10(keccak256('LSP1UniversalReceiverDelegate'))\nbytes10 constant _LSP1_UNIVERSAL_RECEIVER_DELEGATE_PREFIX = 0x0cfc51aec37c55a4d0b1;\n\n// keccak256('LSP1UniversalReceiverDelegate')\nbytes32 constant _LSP1_UNIVERSAL_RECEIVER_DELEGATE_KEY = 0x0cfc51aec37c55a4d0b1a65c6255c4bf2fbdf6277f3cc0730c45b828b6db8b47;\n"
    },
    "@lukso/lsp-smart-contracts/contracts/LSP1UniversalReceiver/LSP1Utils.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.4;\n\n// libraries\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\n// constants\nimport \"./ILSP1UniversalReceiver.sol\";\nimport \"../LSP0ERC725Account/LSP0Constants.sol\";\nimport \"../LSP5ReceivedAssets/LSP5Constants.sol\";\nimport \"../LSP7DigitalAsset/LSP7Constants.sol\";\nimport \"../LSP8IdentifiableDigitalAsset/LSP8Constants.sol\";\nimport \"../LSP9Vault/LSP9Constants.sol\";\nimport \"../LSP14Ownable2Step/LSP14Constants.sol\";\nimport \"../LSP10ReceivedVaults/LSP10Constants.sol\";\n\nlibrary LSP1Utils {\n    function callUniversalReceiverWithCallerInfos(\n        address universalReceiverDelegate,\n        bytes32 typeId,\n        bytes calldata receivedData,\n        address msgSender,\n        uint256 msgValue\n    ) internal returns (bytes memory) {\n        bytes memory callData = abi.encodePacked(\n            abi.encodeWithSelector(\n                ILSP1UniversalReceiver.universalReceiver.selector,\n                typeId,\n                receivedData\n            ),\n            msgSender,\n            msgValue\n        );\n\n        (bool success, bytes memory result) = universalReceiverDelegate.call(callData);\n        Address.verifyCallResult(success, result, \"Call to universalReceiver failed\");\n        return result.length != 0 ? abi.decode(result, (bytes)) : result;\n    }\n\n    /**\n     * @dev Gets all the transfer details depending on the `typeId`\n     * @param typeId A unique identifier for a specific action\n     */\n    function getTransferDetails(bytes32 typeId)\n        internal\n        pure\n        returns (\n            bool invalid,\n            bytes10 mapPrefix,\n            bytes4 interfaceId,\n            bool isReceiving\n        )\n    {\n        if (typeId == _TYPEID_LSP7_TOKENSSENDER || typeId == _TYPEID_LSP7_TOKENSRECIPIENT) {\n            mapPrefix = _LSP5_RECEIVED_ASSETS_MAP_KEY_PREFIX;\n            interfaceId = _INTERFACEID_LSP7;\n            isReceiving = typeId == _TYPEID_LSP7_TOKENSRECIPIENT ? true : false;\n        } else if (typeId == _TYPEID_LSP8_TOKENSSENDER || typeId == _TYPEID_LSP8_TOKENSRECIPIENT) {\n            mapPrefix = _LSP5_RECEIVED_ASSETS_MAP_KEY_PREFIX;\n            interfaceId = _INTERFACEID_LSP8;\n            isReceiving = typeId == _TYPEID_LSP8_TOKENSRECIPIENT ? true : false;\n        } else if (\n            typeId == _TYPEID_LSP9_OwnershipTransferred_SenderNotification ||\n            typeId == _TYPEID_LSP9_OwnershipTransferred_RecipientNotification\n        ) {\n            mapPrefix = _LSP10_VAULTS_MAP_KEY_PREFIX;\n            interfaceId = _INTERFACEID_LSP9;\n            isReceiving = (typeId == _TYPEID_LSP9_OwnershipTransferred_RecipientNotification)\n                ? true\n                : false;\n        } else {\n            invalid = true;\n        }\n    }\n}\n"
    },
    "@lukso/lsp-smart-contracts/contracts/LSP2ERC725YJSONSchema/LSP2Utils.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.4;\n\n// libraries\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\n\n/**\n * @title ERC725 Utility library to encode key types\n * @author Jean Cavallera (CJ-42)\n * @dev based on LSP2 - ERC725Y JSON Schema\n *      https://github.com/lukso-network/LIPs/blob/master/LSPs/LSP-2-ERC725YJSONSchema.md\n */\nlibrary LSP2Utils {\n    using BytesLib for bytes;\n\n    /**\n     * @dev Generates a data key of keyType Singleton\n     * @param keyName The string to hash to generate a Singleton data key\n     * @return a bytes32 dataKey\n     *\n     */\n    function generateSingletonKey(string memory keyName) internal pure returns (bytes32) {\n        return keccak256(bytes(keyName));\n    }\n\n    /**\n     * @dev Generates a data key of keyType Array by hashing `keyName`.\n     * @param keyName The string that will be used to generate an data key of keyType Array\n     */\n    function generateArrayKey(string memory keyName) internal pure returns (bytes32) {\n        bytes memory dataKey = bytes(keyName);\n        require(dataKey.length >= 2, \"MUST be longer than 2 characters\");\n        require(\n            dataKey[dataKey.length - 2] == 0x5b && // \"[\" in utf8 encoded\n                dataKey[dataKey.length - 1] == 0x5d, // \"]\" in utf8\n            \"Missing empty square brackets '[]' at the end of the key name\"\n        );\n\n        return keccak256(dataKey);\n    }\n\n    /**\n     * @dev Generates a Array index data key by concatenating the first 16 bytes of `arrayKey`\n     * and `index` transformed from uint256 to bytes16 (uint256 -> uint128 -> bytes16)\n     * @param arrayKey The key from which we're getting the first half of the Array index data key from\n     * @param index Used to generate the second half of the Array index data key\n     */\n    function generateArrayElementKeyAtIndex(bytes32 arrayKey, uint128 index)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes memory elementInArray = bytes.concat(bytes16(arrayKey), bytes16(index));\n        return bytes32(elementInArray);\n    }\n\n    /**\n     * @dev Generates a data key of keyType Mapping by hashing two strings:\n     * <bytes10(keccak256(firstWord))>:<bytes2(0)>:<bytes20(keccak256(firstWord))>\n     * @param firstWord Used to generate a hash and its first 10 bytes\n     * are used for the first part of the data key of keyType Mapping\n     * @param lastWord Used to generate a hash and its first 20 bytes\n     * are used for the last part of the data key of keyType Mapping\n     */\n    function generateMappingKey(string memory firstWord, string memory lastWord)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32 firstWordHash = keccak256(bytes(firstWord));\n        bytes32 lastWordHash = keccak256(bytes(lastWord));\n\n        bytes memory temporaryBytes = bytes.concat(\n            bytes10(firstWordHash),\n            bytes2(0),\n            bytes20(lastWordHash)\n        );\n\n        return bytes32(temporaryBytes);\n    }\n\n    /**\n     * @dev Generates a data key of keyType Mapping by hashing a string and concatenating it with an address:\n     * <bytes10(keccak256(firstWord))>:<bytes2(0)>:<bytes20(addr)>\n     * @param firstWord Used to generate a hash and its first 10 bytes\n     * are used for the first part of the data key of keyType Mapping\n     * @param addr used for the last part of the data key of keyType Mapping\n     */\n    function generateMappingKey(string memory firstWord, address addr)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32 firstWordHash = keccak256(bytes(firstWord));\n\n        bytes memory temporaryBytes = bytes.concat(\n            bytes10(firstWordHash),\n            bytes2(0),\n            bytes20(addr)\n        );\n\n        return bytes32(temporaryBytes);\n    }\n\n    /**\n     * @dev Generate a data key of keyType Mapping\n     * <bytes10keyPrefix>:<bytes2(0)>:<bytes20Value>\n     * @param keyPrefix First part of the data key of keyType Mapping\n     * @param bytes20Value Second part of the data key of keyType Mapping\n     */\n    function generateMappingKey(bytes10 keyPrefix, bytes20 bytes20Value)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes memory generatedKey = bytes.concat(keyPrefix, bytes2(0), bytes20Value);\n        return bytes32(generatedKey);\n    }\n\n    /**\n     * @dev Generate a data key of keyType MappingWithGrouping by using two strings and an address\n     * <bytes6(keccak256(firstWord))>:<bytes4(keccak256(secondWord))>:<bytes2(0)>:<bytes20(addr)>\n     * @param firstWord Used to generate a hash and its first 6 bytes\n     * are used for the first part of the data key of keyType MappingWithGrouping\n     * @param secondWord Used to generate a hash and its first 4 bytes\n     * are used for the second part of the data key of keyType MappingWithGrouping\n     * @param addr Used for the last part of the data key of keyType MappingWithGrouping\n     */\n    function generateMappingWithGroupingKey(\n        string memory firstWord,\n        string memory secondWord,\n        address addr\n    ) internal pure returns (bytes32) {\n        bytes32 firstWordHash = keccak256(bytes(firstWord));\n        bytes32 secondWordHash = keccak256(bytes(secondWord));\n\n        bytes memory temporaryBytes = bytes.concat(\n            bytes6(firstWordHash),\n            bytes4(secondWordHash),\n            bytes2(0),\n            bytes20(addr)\n        );\n\n        return bytes32(temporaryBytes);\n    }\n\n    /**\n     * @dev Generate a data key of keyType MappingWithGrouping\n     * <bytes10keyPrefix>:<bytes2(0)>:<bytes20Value>\n     * @param keyPrefix Used for the first part of the data key of keyType MappingWithGrouping\n     * @param bytes20Value Used for the first last of the data key of keyType MappingWithGrouping\n     */\n    function generateMappingWithGroupingKey(bytes10 keyPrefix, bytes20 bytes20Value)\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes memory generatedKey = bytes.concat(keyPrefix, bytes2(0), bytes20Value);\n        return bytes32(generatedKey);\n    }\n\n    /**\n     * @dev Generate a JSONURL valueContent\n     * @param hashFunction The function used to hash the JSON file\n     * @param json Bytes value of the JSON file\n     * @param url The URL where the JSON file is hosted\n     */\n    function generateJSONURLValue(\n        string memory hashFunction,\n        string memory json,\n        string memory url\n    ) internal pure returns (bytes memory) {\n        bytes32 hashFunctionDigest = keccak256(bytes(hashFunction));\n        bytes32 jsonDigest = keccak256(bytes(json));\n\n        return abi.encodePacked(bytes4(hashFunctionDigest), jsonDigest, url);\n    }\n\n    /**\n     * @dev Generate a ASSETURL valueContent\n     * @param hashFunction The function used to hash the JSON file\n     * @param assetBytes Bytes value of the JSON file\n     * @param url The URL where the JSON file is hosted\n     */\n    function generateASSETURLValue(\n        string memory hashFunction,\n        string memory assetBytes,\n        string memory url\n    ) internal pure returns (bytes memory) {\n        bytes32 hashFunctionDigest = keccak256(bytes(hashFunction));\n        bytes32 jsonDigest = keccak256(bytes(assetBytes));\n\n        return abi.encodePacked(bytes4(hashFunctionDigest), jsonDigest, url);\n    }\n\n    /**\n     * Verifing if `data` is an encoded array\n     * @param data The value that is to be verified\n     */\n    function isEncodedArray(bytes memory data) internal pure returns (bool) {\n        uint256 nbOfBytes = data.length;\n\n        // there must be at least 32 x length bytes after offset\n        uint256 offset = uint256(bytes32(data));\n        if (nbOfBytes < offset + 32) return false;\n        uint256 arrayLength = data.toUint256(offset);\n\n        //   32 bytes word (= offset)\n        // + 32 bytes word (= array length)\n        // + remaining bytes that make each element of the array\n        if (nbOfBytes < (offset + 32 + (arrayLength * 32))) return false;\n\n        return true;\n    }\n\n    /**\n     * Verifing if `data` is an encoded array of addresses (address[])\n     * @param data The value that is to be verified\n     */\n    function isEncodedArrayOfAddresses(bytes memory data) internal pure returns (bool) {\n        if (!isEncodedArray(data)) return false;\n\n        uint256 offset = uint256(bytes32(data));\n        uint256 arrayLength = data.toUint256(offset);\n\n        uint256 pointer = offset + 32;\n\n        for (uint256 ii = 0; ii < arrayLength; ii = uncheckedIncrement(ii)) {\n            bytes32 key = data.toBytes32(pointer);\n\n            // check that the leading bytes are zero bytes \"00\"\n            // NB: address type is padded on the left (unlike bytes20 type that is padded on the right)\n            if (bytes12(key) != bytes12(0)) return false;\n\n            // increment the pointer\n            pointer += 32;\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev verify that `data` is an array of bytes4 (bytes4[]) encoded according to the Solidity ABI specs.\n     * @param data The value that is to be verified\n     */\n    function isBytes4EncodedArray(bytes memory data) internal pure returns (bool) {\n        if (!isEncodedArray(data)) return false;\n\n        uint256 offset = uint256(bytes32(data));\n        uint256 arrayLength = data.toUint256(offset);\n        uint256 pointer = offset + 32;\n\n        for (uint256 ii = 0; ii < arrayLength; ii = uncheckedIncrement(ii)) {\n            bytes32 key = data.toBytes32(pointer);\n\n            // check that the trailing bytes are zero bytes \"00\"\n            if (uint224(uint256(key)) != 0) return false;\n\n            // increment the pointer\n            pointer += 32;\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Verify the validity of the `compactBytesArray` according to LSP2\n     */\n    function isCompactBytesArray(bytes memory compactBytesArray) internal pure returns (bool) {\n        /**\n         * Pointer will always land on these values:\n         *\n         * \n         * 03 a00000\n         * 05 fff83a0011\n         * 20 aa0000000000000000000000000000000000000000000000000000000000cafe\n         * 12 bb000000000000000000000000000000beef\n         * 19 cc00000000000000000000000000000000000000000000deed\n         * \n         *\n         * The pointer can only land on the length of the following bytes value.\n         */\n        uint256 pointer;\n\n        /**\n         * Check each length byte and make sure that when you reach the last length byte.\n         * Make sure that the last length describes exactly the last bytes value and you do not get out of bounds.\n         */\n        while (pointer < compactBytesArray.length) {\n            if (pointer + 1 >= compactBytesArray.length) return false;\n            uint256 elementLength = uint16(\n                bytes2(abi.encodePacked(compactBytesArray[pointer], compactBytesArray[pointer + 1]))\n            );\n            pointer += elementLength + 2;\n        }\n        if (pointer == compactBytesArray.length) return true;\n        return false;\n    }\n\n    /**\n     * @dev Will return unchecked incremented uint256\n     *      can be used to save gas when iterating over loops\n     */\n    function uncheckedIncrement(uint256 i) internal pure returns (uint256) {\n        unchecked {\n            return i + 1;\n        }\n    }\n}\n"
    },
    "@lukso/lsp-smart-contracts/contracts/LSP5ReceivedAssets/LSP5Constants.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.4;\n\n// --- ERC725Y Data Keys\n\n// keccak256('LSP5ReceivedAssets[]')\nbytes32 constant _LSP5_RECEIVED_ASSETS_ARRAY_KEY = 0x6460ee3c0aac563ccbf76d6e1d07bada78e3a9514e6382b736ed3f478ab7b90b;\n\n// bytes10(keccak256('LSP5ReceivedAssetsMap'))\nbytes10 constant _LSP5_RECEIVED_ASSETS_MAP_KEY_PREFIX = 0x812c4334633eb816c80d;\n"
    },
    "@lukso/lsp-smart-contracts/contracts/LSP6KeyManager/ILSP6KeyManager.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.4;\n\n// interfaces\nimport {IERC1271} from \"@openzeppelin/contracts/interfaces/IERC1271.sol\";\n\n/**\n * @dev Contract acting as a controller of an ERC725 Account, using permissions stored in the ERC725Y storage\n */\ninterface ILSP6KeyManager is\n    IERC1271\n    /* is ERC165 */\n{\n    event Executed(bytes4 indexed selector, uint256 indexed value);\n\n    /**\n     * @notice returns the address of the account linked to this KeyManager\n     * @dev this can be a contract that implements\n     *  - ERC725X only\n     *  - ERC725Y only\n     *  - any ERC725 based contract (so implementing both ERC725X and ERC725Y)\n     *\n     * @return the address of the linked account\n     */\n    function target() external view returns (address);\n\n    /**\n     * @notice get latest nonce for `from` in channel ID: `channelId`\n     * @dev use channel ID = 0 for sequential nonces, any other number for out-of-order execution (= execution in parallel)\n     * @param from the caller or signer address\n     * @param channelId the channel id to retrieve the nonce from\n     */\n    function getNonce(address from, uint128 channelId) external view returns (uint256);\n\n    /**\n     * @notice execute the following payload on the ERC725Account: `payload`\n     * @dev the ERC725Account will return some data on successful call, or revert on failure\n     * @param payload the payload to execute. Obtained in web3 via encodeABI()\n     * @return the data being returned by the ERC725 Account\n     */\n    function execute(bytes calldata payload) external payable returns (bytes memory);\n\n    /**\n     * @dev batch `execute(bytes)`\n     */\n    function execute(uint256[] calldata values, bytes[] calldata payloads)\n        external\n        payable\n        returns (bytes[] memory);\n\n    /**\n     * @dev allows anybody to execute given they have a signed message from an executor\n     * @param signature bytes32 ethereum signature\n     * @param nonce the address' nonce (in a specific `_channel`), obtained via `getNonce(...)`. Used to prevent replay attack\n     * @param payload obtained via encodeABI() in web3\n     * @return the data being returned by the ERC725 Account\n     */\n    function executeRelayCall(\n        bytes calldata signature,\n        uint256 nonce,\n        bytes calldata payload\n    ) external payable returns (bytes memory);\n\n    /**\n     * @dev batch `executeRelayCall(...)`\n     */\n    function executeRelayCall(\n        bytes[] calldata signatures,\n        uint256[] calldata nonces,\n        uint256[] calldata values,\n        bytes[] calldata payloads\n    ) external payable returns (bytes[] memory);\n}\n"
    },
    "@lukso/lsp-smart-contracts/contracts/LSP6KeyManager/LSP6Constants.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.4;\n\nuint256 constant LSP6_VERSION = 6;\n\n// --- ERC165 interface ids\nbytes4 constant _INTERFACEID_LSP6 = 0xfb437414;\n\n// --- ERC725Y Data Keys\n\n// PERMISSIONS KEYS\n\n// keccak256('AddressPermissions[]')\nbytes32 constant _LSP6KEY_ADDRESSPERMISSIONS_ARRAY = 0xdf30dba06db6a30e65354d9a64c609861f089545ca58c6b4dbe31a5f338cb0e3;\n\n// AddressPermissions[index]\nbytes16 constant _LSP6KEY_ADDRESSPERMISSIONS_ARRAY_PREFIX = 0xdf30dba06db6a30e65354d9a64c60986;\n\n// AddressPermissions:...\nbytes6 constant _LSP6KEY_ADDRESSPERMISSIONS_PREFIX = 0x4b80742de2bf;\n\n// bytes6(keccak256('AddressPermissions')) + bytes4(keccak256('Permissions'))\nbytes10 constant _LSP6KEY_ADDRESSPERMISSIONS_PERMISSIONS_PREFIX = 0x4b80742de2bf82acb363; // AddressPermissions:Permissions:<address> --> bytes32\n\n// bytes6(keccak256('AddressPermissions')) + bytes4(keccak256('AllowedERC725YDataKeys'))\nbytes10 constant _LSP6KEY_ADDRESSPERMISSIONS_AllowedERC725YDataKeys_PREFIX = 0x4b80742de2bf866c2911; // AddressPermissions:AllowedERC725YDataKeys:<address> --> bytes[CompactBytesArray]\n\n// bytes6(keccak256('AddressPermissions')) + bytes4(keccak256('AllowedCalls'))\nbytes10 constant _LSP6KEY_ADDRESSPERMISSIONS_ALLOWEDCALLS_PREFIX = 0x4b80742de2bf393a64c7; // AddressPermissions:AllowedCalls:<address>\n\n// DEFAULT PERMISSIONS VALUES\n// NB: the SUPER PERMISSIONS allow to not check for:\n//  - AddressPermissions:AllowedERC725YDataKeys:...\n//  - AddressPermissions:AllowedCalls\nbytes32 constant _PERMISSION_CHANGEOWNER                     = 0x0000000000000000000000000000000000000000000000000000000000000001;\nbytes32 constant _PERMISSION_ADDCONTROLLER                  = 0x0000000000000000000000000000000000000000000000000000000000000002;\nbytes32 constant _PERMISSION_CHANGEPERMISSIONS               = 0x0000000000000000000000000000000000000000000000000000000000000004;\nbytes32 constant _PERMISSION_ADDEXTENSIONS                   = 0x0000000000000000000000000000000000000000000000000000000000000008;\nbytes32 constant _PERMISSION_CHANGEEXTENSIONS                = 0x0000000000000000000000000000000000000000000000000000000000000010;\nbytes32 constant _PERMISSION_ADDUNIVERSALRECEIVERDELEGATE    = 0x0000000000000000000000000000000000000000000000000000000000000020;\nbytes32 constant _PERMISSION_CHANGEUNIVERSALRECEIVERDELEGATE = 0x0000000000000000000000000000000000000000000000000000000000000040;\nbytes32 constant _PERMISSION_REENTRANCY                      = 0x0000000000000000000000000000000000000000000000000000000000000080;\nbytes32 constant _PERMISSION_SUPER_TRANSFERVALUE             = 0x0000000000000000000000000000000000000000000000000000000000000100;\nbytes32 constant _PERMISSION_TRANSFERVALUE                   = 0x0000000000000000000000000000000000000000000000000000000000000200;\nbytes32 constant _PERMISSION_SUPER_CALL                      = 0x0000000000000000000000000000000000000000000000000000000000000400;\nbytes32 constant _PERMISSION_CALL                            = 0x0000000000000000000000000000000000000000000000000000000000000800;\nbytes32 constant _PERMISSION_SUPER_STATICCALL                = 0x0000000000000000000000000000000000000000000000000000000000001000;\nbytes32 constant _PERMISSION_STATICCALL                      = 0x0000000000000000000000000000000000000000000000000000000000002000;\nbytes32 constant _PERMISSION_SUPER_DELEGATECALL              = 0x0000000000000000000000000000000000000000000000000000000000004000;\nbytes32 constant _PERMISSION_DELEGATECALL                    = 0x0000000000000000000000000000000000000000000000000000000000008000;\nbytes32 constant _PERMISSION_DEPLOY                          = 0x0000000000000000000000000000000000000000000000000000000000010000;\nbytes32 constant _PERMISSION_SUPER_SETDATA                   = 0x0000000000000000000000000000000000000000000000000000000000020000;\nbytes32 constant _PERMISSION_SETDATA                         = 0x0000000000000000000000000000000000000000000000000000000000040000;\nbytes32 constant _PERMISSION_ENCRYPT                         = 0x0000000000000000000000000000000000000000000000000000000000080000;\nbytes32 constant _PERMISSION_DECRYPT                         = 0x0000000000000000000000000000000000000000000000000000000000100000;\nbytes32 constant _PERMISSION_SIGN                            = 0x0000000000000000000000000000000000000000000000000000000000200000;\n\n// All Permissions currently exclude REENTRANCY, DELEGATECALL and SUPER_DELEGATECALL for security\nbytes32 constant ALL_REGULAR_PERMISSIONS = 0x00000000000000000000000000000000000000000000000000000000003f3f7f;\n\n// LSP6 overloaded function selectors\nbytes4 constant _LSP6_EXECUTE_SELECTOR = 0x09c5eabe;\nbytes4 constant _LSP6_EXECUTE_BATCH_SELECTOR = 0xbf3e1f7b;\nbytes4 constant _LSP6_EXECUTE_RELAYCALL_SELECTOR = 0x902d5fa0;\nbytes4 constant _LSP6_EXECUTE_RELAYCALL_BATCH_SELECTOR = 0xbd68663a;\n"
    },
    "@lukso/lsp-smart-contracts/contracts/LSP6KeyManager/LSP6Errors.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.4;\n\n/**\n * @dev reverts when address `from` does not have any permissions set\n * on the account linked to this Key Manager\n * @param from the address that does not have permissions\n */\nerror NoPermissionsSet(address from);\n\n/**\n * @dev reverts when address `from` is not authorised to perform `permission` on the linked account\n * @param permission permission required\n * @param from address not-authorised\n */\nerror NotAuthorised(address from, string permission);\n\n/**\n * @dev reverts when `from` is not authorised to make the call because of a not allowed standard, address or function.\n * @param from address making the request\n * @param to the address of an EOA or contract that `from` is trying to interact with\n * @param selector if `to` is a contract, the bytes4 selector of the function that `from` is trying to call.\n * If no function is called (e.g: a native token transfer), selector = 0x00000000\n */\nerror NotAllowedCall(address from, address to, bytes4 selector);\n\n/**\n * @dev reverts when address `from` is not authorised to set the key `disallowedKey` on the linked account\n * @param from address making the request\n * @param disallowedKey a bytes32 key that `from` is not authorised to set on the ERC725Y storage\n */\nerror NotAllowedERC725YDataKey(address from, bytes32 disallowedKey);\n\n/**\n * @dev reverts when `dataKey` is a bytes32 that does not adhere to any of the\n *      permission data keys specified by the LSP6 standard\n *\n * @param dataKey the dataKey that does not match with any of the standard LSP6 permission data keys\n */\nerror NotRecognisedPermissionKey(bytes32 dataKey);\n\n/**\n * @dev reverts when the address provided as a target (= account) linked to this KeyManager is invalid\n *      e.g. address(0)\n */\nerror InvalidLSP6Target();\n\n/**\n * @dev reverts when the `signer` address retrieved from the `signature` has an invalid nonce: `invalidNonce`.\n * @param signer the address of the signer\n * @param invalidNonce the nonce retrieved for the `signer` address\n * @param signature the signature used to retrieve the `signer` address\n */\nerror InvalidRelayNonce(address signer, uint256 invalidNonce, bytes signature);\n\n/**\n * @dev reverts when trying to run an invalid function on the linked target account via the Key Manager.\n * @param invalidFunction the bytes4 selector of the invalid function\n */\nerror InvalidERC725Function(bytes4 invalidFunction);\n\n/**\n * @dev reverts when `allowedCallsValue` is not properly encoded as a bytes28[CompactBytesArray]\n * (CompactBytesArray of bytes28 entries). See LSP2 value type `CompactBytesArray` for details.\n * @param allowedCallsValue the list of allowedCalls\n */\nerror InvalidEncodedAllowedCalls(bytes allowedCallsValue);\n\n/**\n * @dev reverts when trying to set a value that is not 20 bytes long under AddressPermissions[index]\n * @param dataKey the AddressPermissions[index] data key\n * @param invalidValue the invalid value that was attempted to be set under AddressPermissions[index]\n */\nerror AddressPermissionArrayIndexValueNotAnAddress(bytes32 dataKey, bytes invalidValue);\n\n/**\n * @dev reverts if there are no AllowedERC725YDataKeys set for the caller\n * @param from the address that has no AllowedERC725YDataKeys\n */\nerror NoERC725YDataKeysAllowed(address from);\n\n/**\n * @dev reverts if there are no allowed calls set for `from`\n * @param from the address that has no AllowedCalls\n */\nerror NoCallsAllowed(address from);\n\n/**\n * @dev reverts when `value` is not encoded properly using the CompactBytesArray\n * @param value the value to check for an CompactBytesArray\n */\nerror InvalidEncodedAllowedERC725YDataKeys(bytes value);\n\n/**\n * @dev a `from` address is not allowed to have 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n * in its list of AddressPermissions:AllowedCalls:<address>, as this allows any STANDARD:ADDRESS:FUNCTION.\n * This is equivalent to granting the SUPER permission and should never be valid.\n *\n * @param from the address that has any allowed calls whitelisted.\n */\nerror InvalidWhitelistedCall(address from);\n\n/**\n * @dev reverts when providing array parameters of different sizes to `executeRelayCall(bytes[],uint256[],bytes[])`\n */\nerror BatchExecuteRelayCallParamsLengthMismatch();\n\n/**\n * @dev there should be the same number of elements for each array parameters\n * in the following batch functions:\n *  - execute(uint256[],bytes[])\n *  - executeRelayCall(bytes[],uint256[],uint256[],bytes[])\n */\nerror BatchExecuteParamsLengthMismatch();\n\n/**\n * @dev the `msg.value` sent is not enough to cover the sum of all the values being\n * forwarded on each payloads (`values[]` parameter) in the following batch functions:\n *  - execute(uint256[],bytes[])\n *  - executeRelayCall(bytes[],uint256[],uint256[],bytes[])\n */\nerror LSP6BatchInsufficientValueSent(uint256 totalValues, uint256 msgValue);\n\n/**\n * @dev reverts to avoid the KeyManager to holds some remaining funds sent\n * to the following batch functions:\n *  - execute(uint256[],bytes[])\n *  - executeRelayCall(bytes[],uint256[],uint256[],bytes[])\n *\n * This error occurs when `msg.value` is more than the sum of all the values being\n * forwarded on each payloads (`values[]` parameter from the batch functions above).\n */\nerror LSP6BatchExcessiveValueSent(uint256 totalValues, uint256 msgValue);\n\n/**\n * @dev ERC725X operation type 4 (DELEGATECALL) is disallowed by default\n */\nerror DelegateCallDisallowedViaKeyManager();\n\n/**\n * @dev reverts when the payload is invalid.\n */\nerror InvalidPayload(bytes payload);\n"
    },
    "@lukso/lsp-smart-contracts/contracts/LSP6KeyManager/LSP6KeyManager.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.5;\n\n// modules\nimport {LSP6KeyManagerCore} from \"./LSP6KeyManagerCore.sol\";\nimport {InvalidLSP6Target} from \"./LSP6Errors.sol\";\n\n/**\n * @title Implementation of a contract acting as a controller of an ERC725 Account, using permissions stored in the ERC725Y storage\n * @author Fabian Vogelsteller <frozeman>, Jean Cavallera (CJ42), Yamen Merhi (YamenMerhi)\n * @dev all the permissions can be set on the ERC725 Account using `setData(...)` with the keys constants below\n */\ncontract LSP6KeyManager is LSP6KeyManagerCore {\n    /**\n     * @notice Initiate the account with the address of the ERC725Account contract and sets LSP6KeyManager InterfaceId\n     * @param target_ The address of the ER725Account to control\n     */\n    constructor(address target_) {\n        if (target_ == address(0)) revert InvalidLSP6Target();\n        _target = target_;\n        _setupLSP6ReentrancyGuard();\n    }\n}\n"
    },
    "@lukso/lsp-smart-contracts/contracts/LSP6KeyManager/LSP6KeyManagerCore.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.5;\n\n// interfaces\nimport {IERC1271} from \"@openzeppelin/contracts/interfaces/IERC1271.sol\";\nimport {IERC725X} from \"@erc725/smart-contracts/contracts/interfaces/IERC725X.sol\";\nimport {ILSP6KeyManager} from \"./ILSP6KeyManager.sol\";\n\n// modules\nimport {ILSP14Ownable2Step} from \"../LSP14Ownable2Step/ILSP14Ownable2Step.sol\";\nimport {ERC725Y} from \"@erc725/smart-contracts/contracts/ERC725Y.sol\";\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\n// libraries\nimport {GasLib} from \"../Utils/GasLib.sol\";\nimport {BytesLib} from \"solidity-bytes-utils/contracts/BytesLib.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {ERC165Checker} from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\nimport {LSP6Utils} from \"./LSP6Utils.sol\";\nimport {EIP191Signer} from \"../Custom/EIP191Signer.sol\";\n\n// errors\nimport \"./LSP6Errors.sol\";\n\n// constants\nimport {\n    OPERATION_0_CALL,\n    OPERATION_1_CREATE,\n    OPERATION_2_CREATE2,\n    OPERATION_3_STATICCALL,\n    OPERATION_4_DELEGATECALL,\n    SETDATA_SELECTOR,\n    SETDATA_ARRAY_SELECTOR,\n    EXECUTE_SELECTOR\n} from \"@erc725/smart-contracts/contracts/constants.sol\";\nimport {\n    _INTERFACEID_ERC1271,\n    _ERC1271_MAGICVALUE,\n    _ERC1271_FAILVALUE\n} from \"../LSP0ERC725Account/LSP0Constants.sol\";\n\nimport {\n    _LSP1_UNIVERSAL_RECEIVER_DELEGATE_PREFIX,\n    _LSP1_UNIVERSAL_RECEIVER_DELEGATE_KEY\n} from \"../LSP1UniversalReceiver/LSP1Constants.sol\";\n\nimport \"./LSP6Constants.sol\";\n\nimport {_LSP17_EXTENSION_PREFIX} from \"../LSP17ContractExtension/LSP17Constants.sol\";\n\n/**\n * @title Core implementation of the LSP6 Key Manager standard.\n * @author Fabian Vogelsteller <frozeman>, Jean Cavallera (CJ42), Yamen Merhi (YamenMerhi)\n * @dev This contract acts as a controller for an ERC725 Account.\n *      Permissions for controllers are stored in the ERC725Y storage of the ERC725 Account and can be updated using `setData(...)`.\n */\nabstract contract LSP6KeyManagerCore is ERC165, ILSP6KeyManager {\n    using LSP6Utils for *;\n    using Address for address;\n    using ECDSA for bytes32;\n    using ERC165Checker for address;\n    using EIP191Signer for address;\n    using BytesLib for bytes;\n\n    address internal _target;\n\n    // Variables, methods and modifier used for ReentrancyGuard are taken from the link below and modified accordingly.\n    // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.8/contracts/security/ReentrancyGuard.sol\n    bool private _reentrancyStatus;\n\n    mapping(address => mapping(uint256 => uint256)) internal _nonceStore;\n\n    function target() public view returns (address) {\n        return _target;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId == _INTERFACEID_LSP6 ||\n            interfaceId == _INTERFACEID_ERC1271 ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @inheritdoc ILSP6KeyManager\n     */\n    function getNonce(address from, uint128 channelId) public view returns (uint256) {\n        uint256 nonceInChannel = _nonceStore[from][channelId];\n        return (uint256(channelId) << 128) | nonceInChannel;\n    }\n\n    /**\n     * @inheritdoc IERC1271\n     */\n    function isValidSignature(bytes32 dataHash, bytes memory signature)\n        public\n        view\n        returns (bytes4 magicValue)\n    {\n        address recoveredAddress = dataHash.recover(signature);\n\n        return (\n            ERC725Y(_target).getPermissionsFor(recoveredAddress).hasPermission(_PERMISSION_SIGN)\n                ? _ERC1271_MAGICVALUE\n                : _ERC1271_FAILVALUE\n        );\n    }\n\n    /**\n     * @inheritdoc ILSP6KeyManager\n     */\n    function execute(bytes calldata payload) public payable virtual returns (bytes memory) {\n        return _execute(msg.value, payload);\n    }\n\n    /**\n     * @inheritdoc ILSP6KeyManager\n     */\n    function execute(uint256[] calldata values, bytes[] calldata payloads)\n        public\n        payable\n        virtual\n        returns (bytes[] memory)\n    {\n        if (values.length != payloads.length) {\n            revert BatchExecuteParamsLengthMismatch();\n        }\n\n        bytes[] memory results = new bytes[](payloads.length);\n        uint256 totalValues;\n\n        for (uint256 ii; ii < payloads.length; ii = GasLib.uncheckedIncrement(ii)) {\n            if ((totalValues += values[ii]) > msg.value) {\n                revert LSP6BatchInsufficientValueSent(totalValues, msg.value);\n            }\n\n            results[ii] = _execute(values[ii], payloads[ii]);\n        }\n\n        if (totalValues < msg.value) {\n            revert LSP6BatchExcessiveValueSent(totalValues, msg.value);\n        }\n\n        return results;\n    }\n\n    /**\n     * @inheritdoc ILSP6KeyManager\n     */\n    function executeRelayCall(\n        bytes memory signature,\n        uint256 nonce,\n        bytes calldata payload\n    ) public payable virtual returns (bytes memory) {\n        return _executeRelayCall(signature, nonce, msg.value, payload);\n    }\n\n    /**\n     * @inheritdoc ILSP6KeyManager\n     */\n    function executeRelayCall(\n        bytes[] memory signatures,\n        uint256[] calldata nonces,\n        uint256[] calldata values,\n        bytes[] calldata payloads\n    ) public payable virtual returns (bytes[] memory) {\n        if (\n            signatures.length != nonces.length ||\n            nonces.length != values.length ||\n            values.length != payloads.length\n        ) {\n            revert BatchExecuteRelayCallParamsLengthMismatch();\n        }\n\n        bytes[] memory results = new bytes[](payloads.length);\n        uint256 totalValues;\n\n        for (uint256 ii; ii < payloads.length; ii = GasLib.uncheckedIncrement(ii)) {\n            if ((totalValues += values[ii]) > msg.value) {\n                revert LSP6BatchInsufficientValueSent(totalValues, msg.value);\n            }\n\n            results[ii] = _executeRelayCall(signatures[ii], nonces[ii], values[ii], payloads[ii]);\n        }\n\n        if (totalValues < msg.value) {\n            revert LSP6BatchExcessiveValueSent(totalValues, msg.value);\n        }\n\n        return results;\n    }\n\n    function _execute(uint256 msgValue, bytes calldata payload)\n        internal\n        virtual\n        returns (bytes memory)\n    {\n        if (payload.length < 4) {\n            revert InvalidPayload(payload);\n        }\n\n        _nonReentrantBefore(msg.sender);\n        _verifyPermissions(msg.sender, payload);\n        bytes memory result = _executePayload(msgValue, payload);\n        _nonReentrantAfter();\n        return result;\n    }\n\n    function _executeRelayCall(\n        bytes memory signature,\n        uint256 nonce,\n        uint256 msgValue,\n        bytes calldata payload\n    ) internal virtual returns (bytes memory) {\n        if (payload.length < 4) {\n            revert InvalidPayload(payload);\n        }\n\n        bytes memory encodedMessage = abi.encodePacked(\n            LSP6_VERSION,\n            block.chainid,\n            nonce,\n            msgValue,\n            payload\n        );\n\n        address signer = address(this).toDataWithIntendedValidator(encodedMessage).recover(\n            signature\n        );\n\n        _nonReentrantBefore(signer);\n\n        if (!_isValidNonce(signer, nonce)) {\n            revert InvalidRelayNonce(signer, nonce, signature);\n        }\n\n        // increase nonce after successful verification\n        _nonceStore[signer][nonce >> 128]++;\n\n        _verifyPermissions(signer, payload);\n\n        bytes memory result = _executePayload(msgValue, payload);\n\n        _nonReentrantAfter();\n\n        return result;\n    }\n\n    /**\n     * @notice execute the `payload` passed to `execute(...)` or `executeRelayCall(...)`\n     * @param payload the abi-encoded function call to execute on the target.\n     * @return bytes the result from calling the target with `payload`\n     */\n    function _executePayload(uint256 msgValue, bytes calldata payload)\n        internal\n        virtual\n        returns (bytes memory)\n    {\n        emit Executed(bytes4(payload), msgValue);\n\n        (bool success, bytes memory returnData) = _target.call{value: msgValue, gas: gasleft()}(\n            payload\n        );\n        bytes memory result = Address.verifyCallResult(\n            success,\n            returnData,\n            \"LSP6: failed executing payload\"\n        );\n\n        return result.length != 0 ? abi.decode(result, (bytes)) : result;\n    }\n\n    /**\n     * @notice verify the nonce `_idx` for `_from` (obtained via `getNonce(...)`)\n     * @dev \"idx\" is a 256bits (unsigned) integer, where:\n     *          - the 128 leftmost bits = channelId\n     *      and - the 128 rightmost bits = nonce within the channel\n     * @param from caller address\n     * @param idx (channel id + nonce within the channel)\n     */\n    function _isValidNonce(address from, uint256 idx) internal view virtual returns (bool) {\n        // idx % (1 << 128) = nonce\n        // (idx >> 128) = channel\n        // equivalent to: return (nonce == _nonceStore[_from][channel]\n        return (idx % (1 << 128)) == (_nonceStore[from][idx >> 128]);\n    }\n\n    /**\n     * @dev verify if the `from` address is allowed to execute the `payload` on the `target`.\n     * @param from either the caller of `execute(...)` or the signer of `executeRelayCall(...)`.\n     * @param payload the payload to execute on the `target`.\n     */\n    function _verifyPermissions(address from, bytes calldata payload) internal view virtual {\n        bytes32 permissions = ERC725Y(_target).getPermissionsFor(from);\n        if (permissions == bytes32(0)) revert NoPermissionsSet(from);\n\n        bytes4 erc725Function = bytes4(payload);\n\n        // ERC725Y.setData(bytes32,bytes)\n        if (erc725Function == SETDATA_SELECTOR) {\n            (bytes32 inputKey, bytes memory inputValue) = abi.decode(payload[4:], (bytes32, bytes));\n\n            _verifyCanSetData(from, permissions, inputKey, inputValue);\n\n            // ERC725Y.setData(bytes32[],bytes[])\n        } else if (erc725Function == SETDATA_ARRAY_SELECTOR) {\n            (bytes32[] memory inputKeys, bytes[] memory inputValues) = abi.decode(\n                payload[4:],\n                (bytes32[], bytes[])\n            );\n\n            _verifyCanSetData(from, permissions, inputKeys, inputValues);\n\n            // ERC725X.execute(uint256,address,uint256,bytes)\n        } else if (erc725Function == EXECUTE_SELECTOR) {\n            _verifyCanExecute(from, permissions, payload);\n        } else if (\n            erc725Function == ILSP14Ownable2Step.transferOwnership.selector ||\n            erc725Function == ILSP14Ownable2Step.acceptOwnership.selector\n        ) {\n            _requirePermissions(from, permissions, _PERMISSION_CHANGEOWNER);\n        } else {\n            revert InvalidERC725Function(erc725Function);\n        }\n    }\n\n    /**\n     * @dev verify if the `controllerAddress` has the permissions required to set a data key on the ERC725Y storage of the `target`.\n     * @param controllerAddress the address who want to set the data key.\n     * @param controllerPermissions the permissions to be checked against.\n     * @param inputDataKey the data key to set on the `target`.\n     * @param inputDataValue the data value to set for the `inputDataKey`.\n     */\n    function _verifyCanSetData(\n        address controllerAddress,\n        bytes32 controllerPermissions,\n        bytes32 inputDataKey,\n        bytes memory inputDataValue\n    ) internal view virtual {\n        bytes32 requiredPermission = _getPermissionRequiredToSetDataKey(\n            inputDataKey,\n            inputDataValue\n        );\n\n        // CHECK if allowed to set an ERC725Y Data Key\n        if (requiredPermission == _PERMISSION_SETDATA) {\n            // Skip if caller has SUPER permissions\n            if (controllerPermissions.hasPermission(_PERMISSION_SUPER_SETDATA)) return;\n\n            _requirePermissions(controllerAddress, controllerPermissions, _PERMISSION_SETDATA);\n\n            _verifyAllowedERC725YSingleKey(\n                controllerAddress,\n                inputDataKey,\n                ERC725Y(_target).getAllowedERC725YDataKeysFor(controllerAddress)\n            );\n        } else {\n            // Otherwise CHECK the required permission if setting LSP6 permissions, LSP1 Delegate or LSP17 Extensions.\n            _requirePermissions(controllerAddress, controllerPermissions, requiredPermission);\n        }\n    }\n\n    /**\n     * @dev verify if the `controllerAddress` has the permissions required to set an array of data keys on the ERC725Y storage of the `target`.\n     * @param controllerAddress the address who want to set the data keys.\n     * @param controllerPermissions the permissions to be checked against.\n     * @param inputDataKeys an array of data keys to set on the `target`.\n     * @param inputDataValues an array of data values to set for the `inputDataKeys`.\n     */\n    function _verifyCanSetData(\n        address controllerAddress,\n        bytes32 controllerPermissions,\n        bytes32[] memory inputDataKeys,\n        bytes[] memory inputDataValues\n    ) internal view virtual {\n        bool isSettingERC725YKeys;\n        bool[] memory validatedInputDataKeys = new bool[](inputDataKeys.length);\n\n        bytes32 requiredPermission;\n\n        uint256 ii;\n        do {\n            requiredPermission = _getPermissionRequiredToSetDataKey(\n                inputDataKeys[ii],\n                inputDataValues[ii]\n            );\n\n            if (requiredPermission == _PERMISSION_SETDATA) {\n                isSettingERC725YKeys = true;\n            } else {\n                // CHECK the required permissions if setting LSP6 permissions, LSP1 Delegate or LSP17 Extensions.\n                _requirePermissions(controllerAddress, controllerPermissions, requiredPermission);\n                validatedInputDataKeys[ii] = true;\n            }\n\n            ii = GasLib.uncheckedIncrement(ii);\n        } while (ii < inputDataKeys.length);\n\n        // CHECK if allowed to set one (or multiple) ERC725Y Data Keys\n        if (isSettingERC725YKeys) {\n            // Skip if caller has SUPER permissions\n            if (controllerPermissions.hasPermission(_PERMISSION_SUPER_SETDATA)) return;\n\n            _requirePermissions(controllerAddress, controllerPermissions, _PERMISSION_SETDATA);\n\n            _verifyAllowedERC725YDataKeys(\n                controllerAddress,\n                inputDataKeys,\n                ERC725Y(_target).getAllowedERC725YDataKeysFor(controllerAddress),\n                validatedInputDataKeys\n            );\n        }\n    }\n\n    /**\n     * @dev retrieve the permission required based on the data key to be set on the `target`.\n     * @param inputDataKey the data key to set on the `target`. Can be related to LSP6 Permissions, LSP1 Delegate or LSP17 Extensions.\n     * @param inputDataValue the data value to set for the `inputDataKey`.\n     * @return the permission required to set the `inputDataKey` on the `target`.\n     */\n    function _getPermissionRequiredToSetDataKey(bytes32 inputDataKey, bytes memory inputDataValue)\n        internal\n        view\n        virtual\n        returns (bytes32)\n    {\n        // AddressPermissions[] or AddressPermissions[index]\n        if (bytes16(inputDataKey) == _LSP6KEY_ADDRESSPERMISSIONS_ARRAY_PREFIX) {\n            return _getPermissionToSetPermissionsArray(inputDataKey, inputDataValue);\n\n            // AddressPermissions:...\n        } else if (bytes6(inputDataKey) == _LSP6KEY_ADDRESSPERMISSIONS_PREFIX) {\n            // AddressPermissions:Permissions:<address>\n            if (bytes12(inputDataKey) == _LSP6KEY_ADDRESSPERMISSIONS_PERMISSIONS_PREFIX) {\n                return _getPermissionToSetControllerPermissions(inputDataKey);\n\n                // AddressPermissions:AllowedCalls:<address>\n            } else if (bytes12(inputDataKey) == _LSP6KEY_ADDRESSPERMISSIONS_ALLOWEDCALLS_PREFIX) {\n                return _getPermissionToSetAllowedCalls(inputDataKey, inputDataValue);\n\n                // AddressPermissions:AllowedERC725YKeys:<address>\n            } else if (\n                bytes12(inputDataKey) == _LSP6KEY_ADDRESSPERMISSIONS_AllowedERC725YDataKeys_PREFIX\n            ) {\n                return _getPermissionToSetAllowedERC725YDataKeys(inputDataKey, inputDataValue);\n\n                // if the first 6 bytes of the input data key are \"AddressPermissions:...\" but did not match\n                // with anything above, this is not a standard LSP6 permission data key so we revert.\n            } else {\n                /**\n                 * @dev more permissions types starting with `AddressPermissions:...` can be implemented by overriding this function.\n                 *\n                 *      // AddressPermissions:MyCustomPermissions:<address>\n                 *      bytes12 CUSTOM_PERMISSION_PREFIX = 0x4b80742de2bf9e659ba40000\n                 *\n                 *      if (bytes12(dataKey) == CUSTOM_PERMISSION_PREFIX) {\n                 *          // custom logic\n                 *      }\n                 *\n                 *      super._getPermissionRequiredToSetDataKey(...)\n                 */\n                revert NotRecognisedPermissionKey(inputDataKey);\n            }\n\n            // LSP1UniversalReceiverDelegate or LSP1UniversalReceiverDelegate:<typeId>\n        } else if (\n            inputDataKey == _LSP1_UNIVERSAL_RECEIVER_DELEGATE_KEY ||\n            bytes12(inputDataKey) == _LSP1_UNIVERSAL_RECEIVER_DELEGATE_PREFIX\n        ) {\n            return _getPermissionToSetLSP1Delegate(inputDataKey);\n\n            // LSP17Extension:<bytes4>\n        } else if (bytes12(inputDataKey) == _LSP17_EXTENSION_PREFIX) {\n            return _getPermissionToSetLSP17Extension(inputDataKey);\n        } else {\n            return _PERMISSION_SETDATA;\n        }\n    }\n\n    /**\n     * @dev retrieve the permission required to update the `AddressPermissions[]` array data key defined in LSP6.\n     * @param inputDataKey either `AddressPermissions[]` (array length) or `AddressPermissions[index]` (array index)\n     * @param inputDataValue the updated value for the `inputDataKey`. MUST be:\n     *  - a `uint256` for `AddressPermissions[]` (array length)\n     *  - an `address` or `0x` for `AddressPermissions[index]` (array entry).\n     *\n     * @return either ADD or CHANGE PERMISSIONS.\n     */\n    function _getPermissionToSetPermissionsArray(bytes32 inputDataKey, bytes memory inputDataValue)\n        internal\n        view\n        virtual\n        returns (bytes32)\n    {\n        bytes memory currentValue = ERC725Y(_target).getData(inputDataKey);\n\n        // AddressPermissions[] -> array length\n        if (inputDataKey == _LSP6KEY_ADDRESSPERMISSIONS_ARRAY) {\n            uint256 newLength = uint256(bytes32(inputDataValue));\n\n            return\n                newLength > uint256(bytes32(currentValue))\n                    ? _PERMISSION_ADDCONTROLLER\n                    : _PERMISSION_CHANGEPERMISSIONS;\n        }\n\n        // AddressPermissions[index] -> array index\n\n        // CHECK that we either ADD an address (20 bytes long) or REMOVE an address (0x)\n        if (inputDataValue.length != 0 && inputDataValue.length != 20) {\n            revert AddressPermissionArrayIndexValueNotAnAddress(inputDataKey, inputDataValue);\n        }\n\n        return currentValue.length == 0 ? _PERMISSION_ADDCONTROLLER : _PERMISSION_CHANGEPERMISSIONS;\n    }\n\n    /**\n     * @dev retrieve the permission required to set permissions for a controller address.\n     * @param inputPermissionDataKey `AddressPermissions:Permissions:<controller-address>`.\n     * @return either ADD or CHANGE PERMISSIONS.\n     */\n    function _getPermissionToSetControllerPermissions(bytes32 inputPermissionDataKey)\n        internal\n        view\n        virtual\n        returns (bytes32)\n    {\n        return\n            // if there is nothing stored under the data key, we are trying to ADD a new controller.\n            // if there are already some permissions set under the data key, we are trying to CHANGE the permissions of a controller.\n            bytes32(ERC725Y(_target).getData(inputPermissionDataKey)) == bytes32(0)\n                ? _PERMISSION_ADDCONTROLLER\n                : _PERMISSION_CHANGEPERMISSIONS;\n    }\n\n    /**\n     * @dev retrieve the permission required to set some AllowedCalls for a controller.\n     * @param dataKey `AddressPermissions:AllowedCalls:<controller-address>`.\n     * @param dataValue the updated value for the `dataKey`. MUST be a bytes28[CompactBytesArray] of Allowed Calls.\n     * @return either ADD or CHANGE PERMISSIONS.\n     */\n    function _getPermissionToSetAllowedCalls(bytes32 dataKey, bytes memory dataValue)\n        internal\n        view\n        virtual\n        returns (bytes32)\n    {\n        if (!LSP6Utils.isCompactBytesArrayOfAllowedCalls(dataValue)) {\n            revert InvalidEncodedAllowedCalls(dataValue);\n        }\n\n        // if there is nothing stored under the Allowed Calls of the controller,\n        // we are trying to ADD a list of restricted calls (standards + address + function selector)\n        //\n        // if there are already some data set under the Allowed Calls of the controller,\n        // we are trying to CHANGE (= edit) these restrictions.\n        return\n            ERC725Y(_target).getData(dataKey).length == 0\n                ? _PERMISSION_ADDCONTROLLER\n                : _PERMISSION_CHANGEPERMISSIONS;\n    }\n\n    /**\n     * @dev retrieve the permission required to set some AllowedCalls for a controller.\n     * @param dataKey  or `AddressPermissions:AllowedERC725YDataKeys:<controller-address>`.\n     * @param dataValue the updated value for the `dataKey`. MUST be a bytes[CompactBytesArray] of Allowed ERC725Y Data Keys.\n     * @return either ADD or CHANGE PERMISSIONS.\n     */\n    function _getPermissionToSetAllowedERC725YDataKeys(bytes32 dataKey, bytes memory dataValue)\n        internal\n        view\n        returns (bytes32)\n    {\n        if (!LSP6Utils.isCompactBytesArrayOfAllowedERC725YDataKeys(dataValue)) {\n            revert InvalidEncodedAllowedERC725YDataKeys(dataValue);\n        }\n\n        // if there is nothing stored under the Allowed ERC725Y Data Keys of the controller,\n        // we are trying to ADD a list of restricted ERC725Y Data Keys.\n        //\n        // if there are already some data set under the Allowed ERC725Y Data Keys of the controller,\n        // we are trying to CHANGE (= edit) these restricted ERC725Y data keys.\n        return\n            ERC725Y(_target).getData(dataKey).length == 0\n                ? _PERMISSION_ADDCONTROLLER\n                : _PERMISSION_CHANGEPERMISSIONS;\n    }\n\n    /**\n     * @dev retrieve the permission required to either add or change the address\n     * of a LSP1 Universal Receiver Delegate stored under a specific LSP1 data key.\n     * @param lsp1DelegateDataKey either the data key for the default `LSP1UniversalReceiverDelegate`,\n     * or a data key for a specific `LSP1UniversalReceiverDelegate:<typeId>`, starting with `_LSP1_UNIVERSAL_RECEIVER_DELEGATE_PREFIX`.\n     * @return either ADD or CHANGE UNIVERSALRECEIVERDELEGATE.\n     */\n    function _getPermissionToSetLSP1Delegate(bytes32 lsp1DelegateDataKey)\n        internal\n        view\n        virtual\n        returns (bytes32)\n    {\n        return\n            ERC725Y(_target).getData(lsp1DelegateDataKey).length == 0\n                ? _PERMISSION_ADDUNIVERSALRECEIVERDELEGATE\n                : _PERMISSION_CHANGEUNIVERSALRECEIVERDELEGATE;\n    }\n\n    /**\n     * @dev Verify if `from` has the required permissions to either add or change the address\n     * of an LSP0 Extension stored under a specific LSP17Extension data key\n     * @param lsp17ExtensionDataKey the dataKey to set with `_LSP17_EXTENSION_PREFIX` as prefix.\n     */\n    function _getPermissionToSetLSP17Extension(bytes32 lsp17ExtensionDataKey)\n        internal\n        view\n        virtual\n        returns (bytes32)\n    {\n        return\n            ERC725Y(_target).getData(lsp17ExtensionDataKey).length == 0\n                ? _PERMISSION_ADDEXTENSIONS\n                : _PERMISSION_CHANGEEXTENSIONS;\n    }\n\n    /**\n     * @dev Verify if the `inputKey` is present in the list of `allowedERC725KeysCompacted` for the `controllerAddress`.\n     * @param controllerAddress the address of the controller.\n     * @param inputDataKey the data key to verify against the allowed ERC725Y Data Keys for the `controllerAddress`.\n     * @param allowedERC725YDataKeysCompacted a CompactBytesArray of allowed ERC725Y Data Keys for the `controllerAddress`.\n     */\n    function _verifyAllowedERC725YSingleKey(\n        address controllerAddress,\n        bytes32 inputDataKey,\n        bytes memory allowedERC725YDataKeysCompacted\n    ) internal pure virtual {\n        if (allowedERC725YDataKeysCompacted.length == 0)\n            revert NoERC725YDataKeysAllowed(controllerAddress);\n\n        /**\n         * The pointer will always land on the length of each bytes value:\n         *\n         * \n         * 03 a00000\n         * 05 fff83a0011\n         * 20 aa0000000000000000000000000000000000000000000000000000000000cafe\n         * 12 bb000000000000000000000000000000beef\n         * 19 cc00000000000000000000000000000000000000000000deed\n         * \n         *\n         */\n        uint256 pointer;\n\n        // information extracted from each Allowed ERC725Y Data Key.\n        uint256 length;\n        bytes32 allowedKey;\n        bytes32 mask;\n\n        /**\n         * iterate over each data key and update the `pointer` variable with the index where to find the length of each data key.\n         *\n         * 0x 03 a00000 03 fff83a 20 aa00...00cafe\n         *                    \n         *  first  |  second  |  third\n         *  length |  length  |  length\n         */\n        while (pointer < allowedERC725YDataKeysCompacted.length) {\n            // save the length of the allowed data key to calculate the `mask`.\n            length = uint16(\n                bytes2(\n                    abi.encodePacked(\n                        allowedERC725YDataKeysCompacted[pointer],\n                        allowedERC725YDataKeysCompacted[pointer + 1]\n                    )\n                )\n            );\n\n            /**\n             * The bitmask discard the last `32 - length` bytes of the input data key via ANDing &\n             * It is used to compare only the relevant parts of each input data key against dynamic allowed data keys.\n             *\n             * E.g.:\n             *\n             * allowed data key = 0xa00000\n             *\n             *                compare this part\n             *                    vvvvvv\n             * input data key = 0xa00000cafecafecafecafecafecafecafe000000000000000000000011223344\n             *\n             *             &                              discard this part\n             *                       vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\n             *           mask = 0xffffff0000000000000000000000000000000000000000000000000000000000\n             */\n            mask =\n                bytes32(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) <<\n                (8 * (32 - length));\n\n            /*\n             * transform the allowed data key situated from `pointer + 1` until `pointer + 1 + length` to a bytes32 value.\n             * E.g. 0xfff83a -> 0xfff83a0000000000000000000000000000000000000000000000000000000000\n             */\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                // the first 32 bytes word in memory (where allowedERC725YDataKeysCompacted is stored)\n                // correspond to the total number of bytes in `allowedERC725YDataKeysCompacted`\n                let offset := add(add(pointer, 2), 32)\n                let memoryAt := mload(add(allowedERC725YDataKeysCompacted, offset))\n                // MLOAD loads 32 bytes word, so we need to keep only the `length` number of bytes that makes up the allowed data key.\n                allowedKey := and(memoryAt, mask)\n            }\n\n            // voila you found the key ;)\n            if (allowedKey == (inputDataKey & mask)) return;\n\n            // move the pointer to the index of the next allowed data key\n            unchecked {\n                pointer = pointer + (length + 2);\n            }\n        }\n\n        revert NotAllowedERC725YDataKey(controllerAddress, inputDataKey);\n    }\n\n    /**\n     * @dev Verify if all the `inputDataKeys` are present in the list of `allowedERC725KeysCompacted` of the `controllerAddress`.\n     * @param controllerAddress the address of the controller.\n     * @param inputDataKeys the data keys to verify against the allowed ERC725Y Data Keys of the `controllerAddress`.\n     * @param allowedERC725YDataKeysCompacted a CompactBytesArray of allowed ERC725Y Data Keys of the `controllerAddress`.\n     * @param validatedInputKeys an array of booleans to store the result of the verification of each data keys checked.\n     */\n    function _verifyAllowedERC725YDataKeys(\n        address controllerAddress,\n        bytes32[] memory inputDataKeys,\n        bytes memory allowedERC725YDataKeysCompacted,\n        bool[] memory validatedInputKeys\n    ) internal pure virtual {\n        if (allowedERC725YDataKeysCompacted.length == 0)\n            revert NoERC725YDataKeysAllowed(controllerAddress);\n\n        uint256 allowedKeysFound;\n\n        // cache the input data keys from the start\n        uint256 inputKeysLength = inputDataKeys.length;\n\n        /**\n         * The pointer will always land on the length of each bytes value:\n         *\n         * \n         * 03 a00000\n         * 05 fff83a0011\n         * 20 aa0000000000000000000000000000000000000000000000000000000000cafe\n         * 12 bb000000000000000000000000000000beef\n         * 19 cc00000000000000000000000000000000000000000000deed\n         * \n         *\n         */\n        uint256 pointer;\n\n        // information extracted from each Allowed ERC725Y Data Key.\n        uint256 length;\n        bytes32 allowedKey;\n        bytes32 mask;\n\n        /**\n         * iterate over each data key and update the `pointer` variable with the index where to find the length of each data key.\n         *\n         * 0x 03 a00000 03 fff83a 20 aa00...00cafe\n         *                    \n         *  first  |  second  |  third\n         *  length |  length  |  length\n         */\n        while (pointer < allowedERC725YDataKeysCompacted.length) {\n            // save the length of the allowed data key to calculate the `mask`.\n            length = uint16(\n                bytes2(\n                    abi.encodePacked(\n                        allowedERC725YDataKeysCompacted[pointer],\n                        allowedERC725YDataKeysCompacted[pointer + 1]\n                    )\n                )\n            );\n\n            /**\n             * The bitmask discard the last `32 - length` bytes of the input data key via ANDing &\n             * It is used to compare only the relevant parts of each input data key against dynamic allowed data keys.\n             *\n             * E.g.:\n             *\n             * allowed data key = 0xa00000\n             *\n             *                compare this part\n             *                    vvvvvv\n             * input data key = 0xa00000cafecafecafecafecafecafecafe000000000000000000000011223344\n             *\n             *             &                              discard this part\n             *                       vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\n             *           mask = 0xffffff0000000000000000000000000000000000000000000000000000000000\n             */\n            mask =\n                bytes32(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) <<\n                (8 * (32 - length));\n\n            /*\n             * transform the allowed data key situated from `pointer + 1` until `pointer + 1 + length` to a bytes32 value.\n             * E.g. 0xfff83a -> 0xfff83a0000000000000000000000000000000000000000000000000000000000\n             */\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                // the first 32 bytes word in memory (where allowedERC725YDataKeysCompacted is stored)\n                // correspond to the length of allowedERC725YDataKeysCompacted (= total number of bytes)\n                let offset := add(add(pointer, 2), 32)\n                let memoryAt := mload(add(allowedERC725YDataKeysCompacted, offset))\n                allowedKey := and(memoryAt, mask)\n            }\n\n            /**\n             * Iterate over the `inputDataKeys` to check them against the allowed data keys.\n             * This until we have validated them all.\n             */\n            for (uint256 ii; ii < inputKeysLength; ii = GasLib.uncheckedIncrement(ii)) {\n                // if the input data key has been marked as allowed previously,\n                // SKIP it and move to the next input data key.\n                if (validatedInputKeys[ii]) continue;\n\n                // CHECK if the input data key is allowed.\n                if ((inputDataKeys[ii] & mask) == allowedKey) {\n                    // if the input data key is allowed, mark it as allowed\n                    // and increment the number of allowed keys found.\n                    validatedInputKeys[ii] = true;\n                    allowedKeysFound = GasLib.uncheckedIncrement(allowedKeysFound);\n\n                    // Continue checking until all the inputKeys` have been found.\n                    if (allowedKeysFound == inputKeysLength) return;\n                }\n            }\n\n            // Move the pointer to the next AllowedERC725YKey\n            unchecked {\n                pointer = pointer + (length + 2);\n            }\n        }\n\n        // if we did not find all the input data keys, search for the first not allowed data key to revert.\n        for (uint256 jj; jj < inputKeysLength; jj = GasLib.uncheckedIncrement(jj)) {\n            if (!validatedInputKeys[jj]) {\n                revert NotAllowedERC725YDataKey(controllerAddress, inputDataKeys[jj]);\n            }\n        }\n    }\n\n    /**\n     * @dev verify if `from` has the required permissions to interact with other addresses using the target.\n     * @param from the address who want to run the execute function on the ERC725Account\n     * @param permissions the permissions of the caller\n     * @param payload the ABI encoded payload `target.execute(...)`\n     */\n    function _verifyCanExecute(\n        address from,\n        bytes32 permissions,\n        bytes calldata payload\n    ) internal view virtual {\n        // MUST be one of the ERC725X operation types.\n        uint256 operationType = uint256(bytes32(payload[4:36]));\n\n        // DELEGATECALL is disallowed by default on the LSP6 Key Manager.\n        if (operationType == OPERATION_4_DELEGATECALL) {\n            revert DelegateCallDisallowedViaKeyManager();\n        }\n\n        uint256 value = uint256(bytes32(payload[68:100]));\n\n        // prettier-ignore\n        bool isContractCreation = operationType == OPERATION_1_CREATE || operationType == OPERATION_2_CREATE2;\n        bool isCallDataPresent = payload.length > 164;\n\n        // SUPER operation only applies to contract call, not contract creation\n        bool hasSuperOperation = isContractCreation\n            ? false\n            : permissions.hasPermission(_extractSuperPermissionFromOperation(operationType));\n\n        // CHECK if we are doing an empty call, as the receive() or fallback() function\n        // of the target contract could run some code.\n        if (!hasSuperOperation && !isCallDataPresent && value == 0) {\n            _requirePermissions(from, permissions, _extractPermissionFromOperation(operationType));\n        }\n\n        if (isCallDataPresent && !hasSuperOperation) {\n            _requirePermissions(from, permissions, _extractPermissionFromOperation(operationType));\n        }\n\n        bool hasSuperTransferValue = permissions.hasPermission(_PERMISSION_SUPER_TRANSFERVALUE);\n\n        if (value != 0 && !hasSuperTransferValue) {\n            _requirePermissions(from, permissions, _PERMISSION_TRANSFERVALUE);\n        }\n\n        // Skip on contract creation (CREATE or CREATE2)\n        if (isContractCreation) return;\n\n        // Skip if caller has SUPER permissions for external calls, with or without calldata (empty calls)\n        if (hasSuperOperation && value == 0) return;\n\n        // Skip if caller has SUPER permission for value transfers\n        if (hasSuperTransferValue && !isCallDataPresent && value != 0) return;\n\n        // Skip if both SUPER permissions are present\n        if (hasSuperOperation && hasSuperTransferValue) return;\n\n        _verifyAllowedCall(from, payload);\n    }\n\n    function _verifyAllowedCall(address from, bytes calldata payload) internal view virtual {\n        // CHECK for ALLOWED CALLS\n        address to = address(bytes20(payload[48:68]));\n\n        bool containsFunctionCall = payload.length >= 168;\n        bytes4 selector;\n        if (containsFunctionCall) selector = bytes4(payload[164:168]);\n\n        bytes memory allowedCalls = ERC725Y(_target).getAllowedCallsFor(from);\n        uint256 allowedCallsLength = allowedCalls.length;\n\n        if (allowedCallsLength == 0) {\n            revert NoCallsAllowed(from);\n        }\n\n        bool isAllowedStandard;\n        bool isAllowedAddress;\n        bool isAllowedFunction;\n\n        for (uint256 ii; ii < allowedCallsLength; ii += 30) {\n            if (ii + 30 > allowedCallsLength) {\n                revert InvalidEncodedAllowedCalls(allowedCalls);\n            }\n            bytes memory chunk = BytesLib.slice(allowedCalls, ii + 2, 28);\n\n            if (bytes28(chunk) == 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff) {\n                revert InvalidWhitelistedCall(from);\n            }\n\n            bytes4 allowedStandard = bytes4(chunk);\n            address allowedAddress = address(bytes20(bytes28(chunk) << 32));\n            bytes4 allowedFunction = bytes4(bytes28(chunk) << 192);\n\n            isAllowedStandard =\n                allowedStandard == 0xffffffff ||\n                to.supportsERC165InterfaceUnchecked(allowedStandard);\n            isAllowedAddress =\n                allowedAddress == 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF ||\n                to == allowedAddress;\n            isAllowedFunction =\n                allowedFunction == 0xffffffff ||\n                (containsFunctionCall && (selector == allowedFunction));\n\n            if (isAllowedStandard && isAllowedAddress && isAllowedFunction) return;\n        }\n\n        revert NotAllowedCall(from, to, selector);\n    }\n\n    /**\n     * @dev extract the required permission + a descriptive string, based on the `_operationType`\n     * being run via ERC725Account.execute(...)\n     * @param operationType 0 = CALL, 1 = CREATE, 2 = CREATE2, etc... See ERC725X docs for more infos.\n     * @return permissionsRequired (bytes32) the permission associated with the `_operationType`\n     */\n    function _extractPermissionFromOperation(uint256 operationType)\n        internal\n        pure\n        virtual\n        returns (bytes32 permissionsRequired)\n    {\n        if (operationType == OPERATION_0_CALL) return _PERMISSION_CALL;\n        else if (operationType == OPERATION_1_CREATE) return _PERMISSION_DEPLOY;\n        else if (operationType == OPERATION_2_CREATE2) return _PERMISSION_DEPLOY;\n        else if (operationType == OPERATION_3_STATICCALL) return _PERMISSION_STATICCALL;\n        else if (operationType == OPERATION_4_DELEGATECALL) return _PERMISSION_DELEGATECALL;\n    }\n\n    /**\n     * @dev returns the `superPermission` needed for a specific `operationType` of the `execute(..)`\n     */\n    function _extractSuperPermissionFromOperation(uint256 operationType)\n        internal\n        pure\n        virtual\n        returns (bytes32 superPermission)\n    {\n        if (operationType == OPERATION_0_CALL) return _PERMISSION_SUPER_CALL;\n        else if (operationType == OPERATION_3_STATICCALL) return _PERMISSION_SUPER_STATICCALL;\n        else if (operationType == OPERATION_4_DELEGATECALL) return _PERMISSION_SUPER_DELEGATECALL;\n    }\n\n    /**\n     * @dev revert if `from`'s `addressPermissions` doesn't contain `permissionsRequired`\n     * @param from the caller address\n     * @param addressPermissions the caller's permissions BitArray\n     * @param permissionRequired the required permission\n     */\n    function _requirePermissions(\n        address from,\n        bytes32 addressPermissions,\n        bytes32 permissionRequired\n    ) internal pure virtual {\n        if (!addressPermissions.hasPermission(permissionRequired)) {\n            string memory permissionErrorString = _getPermissionName(permissionRequired);\n            revert NotAuthorised(from, permissionErrorString);\n        }\n    }\n\n    /**\n     * @dev returns the name of the permission as a string\n     */\n    function _getPermissionName(bytes32 permission)\n        internal\n        pure\n        virtual\n        returns (string memory errorMessage)\n    {\n        if (permission == _PERMISSION_CHANGEOWNER) return \"TRANSFEROWNERSHIP\";\n        if (permission == _PERMISSION_CHANGEPERMISSIONS) return \"CHANGEPERMISSIONS\";\n        if (permission == _PERMISSION_ADDCONTROLLER) return \"ADDCONTROLLER\";\n        if (permission == _PERMISSION_ADDEXTENSIONS) return \"ADDEXTENSIONS\";\n        if (permission == _PERMISSION_CHANGEEXTENSIONS) return \"CHANGEEXTENSIONS\";\n        if (permission == _PERMISSION_ADDUNIVERSALRECEIVERDELEGATE)\n            return \"ADDUNIVERSALRECEIVERDELEGATE\";\n        if (permission == _PERMISSION_CHANGEUNIVERSALRECEIVERDELEGATE)\n            return \"CHANGEUNIVERSALRECEIVERDELEGATE\";\n        if (permission == _PERMISSION_REENTRANCY) return \"REENTRANCY\";\n        if (permission == _PERMISSION_SETDATA) return \"SETDATA\";\n        if (permission == _PERMISSION_CALL) return \"CALL\";\n        if (permission == _PERMISSION_STATICCALL) return \"STATICCALL\";\n        if (permission == _PERMISSION_DELEGATECALL) return \"DELEGATECALL\";\n        if (permission == _PERMISSION_DEPLOY) return \"DEPLOY\";\n        if (permission == _PERMISSION_TRANSFERVALUE) return \"TRANSFERVALUE\";\n        if (permission == _PERMISSION_SIGN) return \"SIGN\";\n    }\n\n    /**\n     * @dev Initialise _reentrancyStatus to _NOT_ENTERED.\n     */\n    function _setupLSP6ReentrancyGuard() internal virtual {\n        _reentrancyStatus = false;\n    }\n\n    /**\n     * @dev Update the status from `_NON_ENTERED` to `_ENTERED` and checks if\n     * the status is `_ENTERED` in order to revert the call unless the caller has the REENTRANCY permission\n     * Used in the beginning of the `nonReentrant` modifier, before the method execution starts.\n     */\n    function _nonReentrantBefore(address from) internal virtual {\n        if (_reentrancyStatus) {\n            // CHECK the caller has REENTRANCY permission\n            _requirePermissions(\n                from,\n                ERC725Y(_target).getPermissionsFor(from),\n                _PERMISSION_REENTRANCY\n            );\n        } else {\n            _reentrancyStatus = true;\n        }\n    }\n\n    /**\n     * @dev Resets the status to `_NOT_ENTERED`\n     * Used in the end of the `nonReentrant` modifier after the method execution is terminated\n     */\n    function _nonReentrantAfter() internal virtual {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _reentrancyStatus = false;\n    }\n}\n"
    },
    "@lukso/lsp-smart-contracts/contracts/LSP6KeyManager/LSP6Utils.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.4;\n\n// interfaces\nimport {IERC725Y} from \"@erc725/smart-contracts/contracts/interfaces/IERC725Y.sol\";\nimport {ILSP6KeyManager} from \"./ILSP6KeyManager.sol\";\n\n// libraries\nimport {LSP2Utils} from \"../LSP2ERC725YJSONSchema/LSP2Utils.sol\";\n\n// constants\nimport {SETDATA_ARRAY_SELECTOR} from \"@erc725/smart-contracts/contracts/constants.sol\";\nimport \"../LSP6KeyManager/LSP6Constants.sol\";\n\nlibrary LSP6Utils {\n    using LSP2Utils for bytes12;\n\n    /**\n     * @dev read the permissions of a `caller` on an ERC725Y `target` contract.\n     * @param target an `IERC725Y` contract where to read the permissions.\n     * @param caller the controller address to read the permissions from.\n     * @return a `bytes32` BitArray containing the permissions of a controller address.\n     */\n    function getPermissionsFor(IERC725Y target, address caller) internal view returns (bytes32) {\n        bytes memory permissions = target.getData(\n            LSP2Utils.generateMappingWithGroupingKey(\n                _LSP6KEY_ADDRESSPERMISSIONS_PERMISSIONS_PREFIX,\n                bytes20(caller)\n            )\n        );\n\n        return bytes32(permissions);\n    }\n\n    function getAllowedCallsFor(IERC725Y target, address from)\n        internal\n        view\n        returns (bytes memory)\n    {\n        return\n            target.getData(\n                LSP2Utils.generateMappingWithGroupingKey(\n                    _LSP6KEY_ADDRESSPERMISSIONS_ALLOWEDCALLS_PREFIX,\n                    bytes20(from)\n                )\n            );\n    }\n\n    /**\n     * @dev read the Allowed ERC725Y data keys of a `caller` on an ERC725Y `target` contract.\n     * @param target an `IERC725Y` contract where to read the permissions.\n     * @param caller the controller address to read the permissions from.\n     * @return an abi-encoded array of allowed ERC725 keys that the controller address is allowed to interact with.\n     */\n    function getAllowedERC725YDataKeysFor(IERC725Y target, address caller)\n        internal\n        view\n        returns (bytes memory)\n    {\n        return\n            target.getData(\n                LSP2Utils.generateMappingWithGroupingKey(\n                    _LSP6KEY_ADDRESSPERMISSIONS_AllowedERC725YDataKeys_PREFIX,\n                    bytes20(caller)\n                )\n            );\n    }\n\n    /**\n     * @dev compare the permissions `addressPermissions` of an address\n     *      to check if they includes the permissions `permissionToCheck`\n     * @param addressPermission the permissions of an address stored on an ERC725 account\n     * @param permissionToCheck the permissions to check\n     * @return true if `addressPermissions` includes `permissionToCheck`, false otherwise\n     */\n    function hasPermission(bytes32 addressPermission, bytes32 permissionToCheck)\n        internal\n        pure\n        returns (bool)\n    {\n        return (addressPermission & permissionToCheck) == permissionToCheck;\n    }\n\n    /**\n     * @dev same as LSP2Utils.isCompactBytesArray with the additional requirement that each element must be 28 bytes long.\n     *\n     * @param allowedCallsCompacted a compact bytes array of tuples (bytes4,address,bytes4) to check.\n     * @return true if the value passed is a valid compact bytes array of bytes28 elements according to LSP2, false otherwise.\n     */\n    function isCompactBytesArrayOfAllowedCalls(bytes memory allowedCallsCompacted)\n        internal\n        pure\n        returns (bool)\n    {\n        uint256 pointer;\n\n        while (pointer < allowedCallsCompacted.length) {\n            if (pointer + 1 >= allowedCallsCompacted.length) return false;\n            uint256 elementLength = uint16(\n                bytes2(\n                    abi.encodePacked(\n                        allowedCallsCompacted[pointer],\n                        allowedCallsCompacted[pointer + 1]\n                    )\n                )\n            );\n            // each entries in the allowedCalls (compact) array must be 28 bytes long\n            if (elementLength != 28) return false;\n            pointer += elementLength + 2;\n        }\n        if (pointer == allowedCallsCompacted.length) return true;\n        return false;\n    }\n\n    /**\n     * @dev same as LSP2Utils.isCompactBytesArray with the additional requirement that each element must be from 1 to 32 bytes long.\n     *\n     * @param allowedERC725YDataKeysCompacted a compact bytes array of ERC725Y Data Keys (full bytes32 data keys or bytesN prefix) to check.\n     * @return true if the value passed is a valid compact bytes array of ERC725Y Data Keys, false otherwise.\n     */\n    function isCompactBytesArrayOfAllowedERC725YDataKeys(\n        bytes memory allowedERC725YDataKeysCompacted\n    ) internal pure returns (bool) {\n        uint256 pointer;\n\n        while (pointer < allowedERC725YDataKeysCompacted.length) {\n            if (pointer + 1 >= allowedERC725YDataKeysCompacted.length) return false;\n            uint256 elementLength = uint16(\n                bytes2(\n                    abi.encodePacked(\n                        allowedERC725YDataKeysCompacted[pointer],\n                        allowedERC725YDataKeysCompacted[pointer + 1]\n                    )\n                )\n            );\n            // the length of the allowed data key must be not under 33 bytes and not 0\n            if (elementLength == 0 || elementLength > 32) return false;\n            pointer += elementLength + 2;\n        }\n        if (pointer == allowedERC725YDataKeysCompacted.length) return true;\n        return false;\n    }\n\n    /**\n     * @dev use the `setData(bytes32[],bytes[])` via the KeyManager of the target\n     * @param keyManagerAddress the address of the KeyManager\n     * @param keys the array of data keys\n     * @param values the array of data values\n     */\n    function setDataViaKeyManager(\n        address keyManagerAddress,\n        bytes32[] memory keys,\n        bytes[] memory values\n    ) internal returns (bytes memory result) {\n        bytes memory payload = abi.encodeWithSelector(SETDATA_ARRAY_SELECTOR, keys, values);\n        result = ILSP6KeyManager(keyManagerAddress).execute(payload);\n    }\n\n    /**\n     * @dev combine multiple permissions into a single bytes32\n     * Make sure that the sum of the values of the input array is less than 2^256-1 to avoid overflow.\n     * @param _permissions the array of permissions to combine\n     * @return a bytes32 containing the combined permissions\n     */\n    function combinePermissions(bytes32[] memory _permissions) internal pure returns (bytes32) {\n        uint256 result = 0;\n        for (uint256 i = 0; i < _permissions.length; i++) {\n            result += uint256(_permissions[i]);\n        }\n        return bytes32(result);\n    }\n\n    function generatePermissionsKeysForController(\n        IERC725Y _account,\n        address _address,\n        bytes32 permissions\n    ) internal view returns (bytes32[] memory keys, bytes[] memory values) {\n        keys = new bytes32[](3);\n        values = new bytes[](3);\n\n        uint256 arrayLength = uint256(bytes32(_account.getData(_LSP6KEY_ADDRESSPERMISSIONS_ARRAY)));\n        uint256 newArrayLength = arrayLength + 1;\n\n        keys[0] = _LSP6KEY_ADDRESSPERMISSIONS_ARRAY;\n        values[0] = abi.encodePacked(newArrayLength);\n\n        keys[1] = LSP2Utils.generateArrayElementKeyAtIndex(\n            _LSP6KEY_ADDRESSPERMISSIONS_ARRAY,\n            uint128(arrayLength)\n        );\n        values[1] = abi.encodePacked(_address);\n\n        keys[2] = LSP2Utils.generateMappingWithGroupingKey(\n            _LSP6KEY_ADDRESSPERMISSIONS_PERMISSIONS_PREFIX,\n            bytes20(_address)\n        );\n        values[2] = abi.encodePacked(permissions);\n    }\n}\n"
    },
    "@lukso/lsp-smart-contracts/contracts/LSP7DigitalAsset/LSP7Constants.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.4;\n\n// --- ERC165 interface ids\nbytes4 constant _INTERFACEID_LSP7 = 0xda1f85e4;\n\n// --- Token Hooks\n\n// keccak256('LSP7Tokens_SenderNotification')\nbytes32 constant _TYPEID_LSP7_TOKENSSENDER = 0x429ac7a06903dbc9c13dfcb3c9d11df8194581fa047c96d7a4171fc7402958ea;\n\n// keccak256('LSP7Tokens_RecipientNotification')\nbytes32 constant _TYPEID_LSP7_TOKENSRECIPIENT = 0x20804611b3e2ea21c480dc465142210acf4a2485947541770ec1fb87dee4a55c;\n"
    },
    "@lukso/lsp-smart-contracts/contracts/LSP8IdentifiableDigitalAsset/LSP8Constants.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.4;\n\n// --- ERC165 interface ids\nbytes4 constant _INTERFACEID_LSP8 = 0x622e7a01;\n\n// --- ERC725Y Data Keys\n\n// bytes10(keccak256('LSP8MetadataAddress')) + bytes2(0)\nbytes12 constant _LSP8_METADATA_ADDRESS_KEY_PREFIX = 0x73dcc7c3c4096cdc7f8a0000;\n\n// bytes10(keccak256('LSP8MetadataJSON')) + bytes2(0)\nbytes12 constant _LSP8_METADATA_JSON_KEY_PREFIX = 0x9a26b4060ae7f7d5e3cd0000;\n\n// --- Token Hooks\n\n// keccak256('LSP8Tokens_SenderNotification')\nbytes32 constant _TYPEID_LSP8_TOKENSSENDER = 0xb23eae7e6d1564b295b4c3e3be402d9a2f0776c57bdf365903496f6fa481ab00;\n\n// keccak256('LSP8Tokens_RecipientNotification')\nbytes32 constant _TYPEID_LSP8_TOKENSRECIPIENT = 0x0b084a55ebf70fd3c06fd755269dac2212c4d3f0f4d09079780bfa50c1b2984d;\n"
    },
    "@lukso/lsp-smart-contracts/contracts/LSP9Vault/LSP9Constants.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\npragma solidity ^0.8.4;\n\n// --- ERC165 interface ids\nbytes4 constant _INTERFACEID_LSP9 = 0x7050cee9;\n\n// --- ERC725Y Data Keys\n\n// bytes10(keccak256('SupportedStandards')) + bytes2(0) + bytes20(keccak256('LSP9Vault'))\nbytes32 constant _LSP9_SUPPORTED_STANDARDS_KEY = 0xeafec4d89fa9619884b600007c0334a14085fefa8b51ae5a40895018882bdb90;\n\n// bytes4(keccak256('LSP9Vault'))\nbytes constant _LSP9_SUPPORTED_STANDARDS_VALUE = hex\"7c0334a1\";\n\n// Ownerhsip Transfer Type IDs\n\n// keccak256('LSP9OwnershipTransferStarted')\nbytes32 constant _TYPEID_LSP9_OwnershipTransferStarted = 0xaefd43f45fed1bcd8992f23c803b6f4ec45cf6b62b0d404d565f290a471e763f;\n\n// keccak256('LSP9OwnershipTransferred_SenderNotification')\nbytes32 constant _TYPEID_LSP9_OwnershipTransferred_SenderNotification = 0x0c622e58e6b7089ae35f1af1c86d997be92fcdd8c9509652022d41aa65169471;\n\n// keccak256('LSP9OwnershipTransferred_RecipientNotification')\nbytes32 constant _TYPEID_LSP9_OwnershipTransferred_RecipientNotification = 0x79855c97dbc259ce395421d933d7bc0699b0f1561f988f09a9e8633fd542fe5c;\n"
    },
    "@lukso/lsp-smart-contracts/contracts/Utils/GasLib.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.4;\n\n/**\n * @dev Library to add all efficient functions that could get repeated.\n */\nlibrary GasLib {\n    /**\n     * @dev Will return unchecked incremented uint256\n     *      can be used to save gas when iterating over loops\n     */\n    function uncheckedIncrement(uint256 i) internal pure returns (uint256) {\n        unchecked {\n            return i + 1;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n *\n * _Available since v4.1._\n */\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash      Hash of the data to be signed\n     * @param signature Signature byte array associated with _data\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Create2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Create2.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(\n        uint256 amount,\n        bytes32 salt,\n        bytes memory bytecode\n    ) internal returns (address addr) {\n        require(address(this).balance >= amount, \"Create2: insufficient balance\");\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(\n        bytes32 salt,\n        bytes32 bytecodeHash,\n        address deployer\n    ) internal pure returns (address addr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40) // Get free memory pointer\n\n            // |                   |  ptr ...   ptr + 0x0B (start) ...   ptr + 0x20 ...   ptr + 0x40 ...   |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\n            // | 0xFF              |            FF                                                             |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\n            // | keccak(start, 85) |             |\n\n            mstore(add(ptr, 0x40), bytecodeHash)\n            mstore(add(ptr, 0x20), salt)\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\n            mstore8(start, 0xff)\n            addr := keccak256(start, 85)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165Checker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.2) (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface.\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\n            !supportsERC165InterfaceUnchecked(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\n        internal\n        view\n        returns (bool[] memory)\n    {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     *\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\n     * should be exercised when using this function.\n     *\n     * Interface identification is specified in ERC-165.\n     */\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\n        // prepare call\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\n\n        // perform static call\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly {\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0x00)\n        }\n\n        return success && returnSize >= 0x20 && returnValue > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "contracts/interfaces/IERC5564Announcer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\ninterface IERC5564Announcer {\n    /**\n     * @dev Emitted when a stealth transfer is announced\n     * @param schemeId The ID of the stealth address scheme (1 for secp256k1)\n     * @param stealthAddress The stealth address where funds were sent\n     * @param caller The address that called the announce function\n     * @param ephemeralPubKey The ephemeral public key used to generate the stealth address\n     * @param metadata Additional metadata about the transfer\n     */\n    event Announcement(\n        uint256 indexed schemeId,\n        address indexed stealthAddress,\n        address indexed caller,\n        bytes ephemeralPubKey,\n        bytes metadata\n    );\n\n    /**\n     * @dev Announces a stealth transfer\n     * @param schemeId The ID of the stealth address scheme\n     * @param stealthAddress The stealth address where funds were sent\n     * @param ephemeralPubKey The ephemeral public key used to generate the stealth address\n     * @param metadata Additional metadata about the transfer\n     */\n    function announce(\n        uint256 schemeId,\n        address stealthAddress,\n        bytes memory ephemeralPubKey,\n        bytes memory metadata\n    ) external;\n} "
    },
    "contracts/protocol/DispasStealth.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.28;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../interfaces/IERC5564Announcer.sol\";\nimport \"@lukso/lsp-smart-contracts/contracts/LSP0ERC725Account/LSP0ERC725Account.sol\";\nimport \"@lukso/lsp-smart-contracts/contracts/LSP6KeyManager/LSP6KeyManager.sol\";\n\ncontract DispasStealth {\n    IERC5564Announcer public immutable STEALTH_ANNOUNCER;\n    uint256 public constant SCHEME_ID = 1; // SECP256K1 scheme\n\n    mapping(address => bytes32) private stealthMetadata;\n    mapping(address => Announcement[]) private announcements;\n    \n    event StealthMetadataRegistered(address indexed account, bytes32 metadata);\n    event StealthTransfer(\n        address indexed from,\n        address indexed to,\n        address ephemeralAddress,\n        uint256 amount\n    );\n\n    constructor(address announcer) {\n        require(announcer != address(0), \"Zero address\");\n        STEALTH_ANNOUNCER = IERC5564Announcer(announcer);\n    }\n\n    function registerStealthMetadata(address account, bytes32 metadata) external {\n        // Check if the account is a Universal Profile and if msg.sender is its owner\n        LSP0ERC725Account up = LSP0ERC725Account(payable(account));\n        require(msg.sender == up.owner(), \"Not authorized\");\n        \n        stealthMetadata[account] = metadata;\n        emit StealthMetadataRegistered(account, metadata);\n    }\n\n    function getStealthMetadata(address account) external view returns (bytes32) {\n        return stealthMetadata[account];\n    }\n\n    function sendStealthTransfer(\n        address from,\n        address to,\n        address ephemeralAddress\n    ) external payable {\n        require(msg.value > 0, \"Zero amount\");\n        require(stealthMetadata[to] != bytes32(0), \"Recipient has no stealth metadata\");\n        \n        // Check if sender UP has enough balance\n        LSP0ERC725Account upFrom = LSP0ERC725Account(payable(from));\n        require(address(upFrom).balance >= msg.value, \"Insufficient balance\");\n        \n        // Check authorization\n        require(msg.sender == upFrom.owner(), \"Not authorized\");\n        \n        // Transfer the funds\n        (bool success, ) = to.call{value: msg.value}(\"\");\n        require(success, \"Transfer failed\");\n\n        // Announce the transfer\n        STEALTH_ANNOUNCER.announce(\n            SCHEME_ID,\n            ephemeralAddress,\n            abi.encodePacked(stealthMetadata[to]),\n            abi.encode(msg.value)\n        );\n\n        // Store the announcement\n        announcements[to].push(Announcement({\n            recipient: to,\n            ephemeralAddress: ephemeralAddress,\n            amount: msg.value\n        }));\n\n        emit StealthTransfer(from, to, ephemeralAddress, msg.value);\n    }\n\n    function getAnnouncements(address recipient) external view returns (\n        Announcement[] memory\n    ) {\n        return announcements[recipient];\n    }\n\n    struct Announcement {\n        address recipient;\n        address ephemeralAddress;\n        uint256 amount;\n    }\n} "
    },
    "solidity-bytes-utils/contracts/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonalo S <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity >=0.8.0 <0.9.0;\n\n\nlibrary BytesLib {\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n              not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes.slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                                ),\n                                // and now shift left the number of bytes to\n                                // leave space for the length in the slot\n                                exp(0x100, sub(32, newlength))\n                            ),\n                            // increase length by the double of the memory\n                            // bytes length\n                            mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                    sc,\n                    add(\n                        and(\n                            fslot,\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                        ),\n                        and(mload(mc), mask)\n                    )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1 , \"toUint8_outOfBounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, \"toUint32_outOfBounds\");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, \"toUint64_outOfBounds\");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, \"toUint96_outOfBounds\");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, \"toUint128_outOfBounds\");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, \"toUint256_outOfBounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, \"toBytes32_outOfBounds\");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        view\n        returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint256(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}